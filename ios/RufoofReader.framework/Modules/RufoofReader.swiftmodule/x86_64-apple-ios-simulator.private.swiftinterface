// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target x86_64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RufoofReader
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Accelerate
import CommonCrypto
import Compression
import CoreFoundation
import CoreGraphics
import CoreImage
import CoreMotion
import Darwin
import DeveloperToolsSupport
import Dispatch
import Foundation
import Foundation/*.Data*/
import MediaPlayer
import MessageUI
import MobileCoreServices
import QuartzCore
@_exported import RufoofReader
import SQLite3
import Social
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
public struct Entry : Swift.Equatable {
  public enum EntryType : Swift.Int {
    case file
    case directory
    case symlink
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func path(using encoding: Swift.String.Encoding) -> Swift.String
  public var path: Swift.String {
    get
  }
  public var fileAttributes: [Foundation.FileAttributeKey : Any] {
    get
  }
  public var checksum: RufoofReader.CRC32 {
    get
  }
  public var type: RufoofReader.Entry.EntryType {
    get
  }
  public var compressedSize: Swift.UInt64 {
    get
  }
  public var uncompressedSize: Swift.UInt64 {
    get
  }
  public static func == (lhs: RufoofReader.Entry, rhs: RufoofReader.Entry) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class RRStatsMonitor {
  public func startSession(_ bookId: Swift.Int, bookFileId: Swift.Int, startOffset: Swift.Int, wordsPerPage: Swift.Int, wordsPerMinute: Swift.Int)
  public func startAudioSession(_ bookId: Swift.Int, bookFileId: Swift.Int, startOffset: Swift.Int)
  public func endSession(_ restart: Swift.Bool)
  public func endAudioSession(_ restart: Swift.Bool, pagesRead: Swift.Int)
  public func logPage(_ offset: Swift.Int, length: Swift.Int, wordCount: Swift.Int)
  public func logAudioPage(_ offset: Swift.Int, length: Swift.Int, pagesRead: Swift.Int)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class AEADXChaCha20Poly1305 : RufoofReader.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
public class DiskCache : RufoofReader.DiskCacheable {
  public typealias Key = Swift.String
  public typealias Value = Foundation.Data
  public var costLimit: Swift.Int32
  public var countLimit: Swift.Int32
  public var ageLimit: RufoofReader.CacheAge
  public var autoTrimInterval: Foundation.TimeInterval
  public var shouldAutoTrim: Swift.Bool {
    get
    set
  }
  public var totalCount: Swift.Int32 {
    get
  }
  public func totalCountWithHandler(handler: @escaping (Swift.Int32) -> Swift.Void)
  public var totalCost: Swift.Int32 {
    get
  }
  public func totalCostWithHandler(handler: @escaping (Swift.Int32) -> Swift.Void)
  required public init?(path: Swift.String, sizeThreshold threshold: Swift.Int32)
  @objc deinit
}
extension RufoofReader.DiskCache {
  public func containsObject(key: RufoofReader.DiskCache.Key) -> Swift.Bool
  public func query(key: RufoofReader.DiskCache.Key) -> RufoofReader.DiskCache.Value?
  public func save(value: RufoofReader.DiskCache.Value?, for key: RufoofReader.DiskCache.Key)
  public func save(_ dataWork: @escaping () -> (RufoofReader.DiskCache.Value, Swift.Int)?, forKey key: RufoofReader.DiskCache.Key)
  public func remove(key: RufoofReader.DiskCache.Key)
  public func removeAll()
  public func getCacheModifiedDateByKey(key: Swift.String) -> Foundation.Date?
}
extension RufoofReader.DiskCache {
  public func containsObject(key: RufoofReader.DiskCache.Key, _ result: @escaping ((RufoofReader.DiskCache.Key, Swift.Bool) -> Swift.Void))
  public func query(key: RufoofReader.DiskCache.Key, _ result: @escaping ((RufoofReader.DiskCache.Key, RufoofReader.DiskCache.Value?) -> Swift.Void))
  public func save(value: RufoofReader.DiskCache.Value?, for key: RufoofReader.DiskCache.Key, _ result: @escaping (() -> Swift.Void))
  public func save(_ dataWork: @escaping () -> (RufoofReader.DiskCache.Value, Swift.Int)?, forKey key: RufoofReader.DiskCache.Key, result: @escaping (() -> Swift.Void))
  public func remove(key: RufoofReader.DiskCache.Key, _ result: @escaping ((RufoofReader.DiskCache.Key) -> Swift.Void))
  public func removeAll(_ result: @escaping (() -> Swift.Void))
}
public struct PCBC : RufoofReader.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RufoofReader.PCBC.Error, b: RufoofReader.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: RufoofReader.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : RufoofReader.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, eme_pkcs1v15, emsa_pkcs1v15, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: RufoofReader.Padding, b: RufoofReader.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RufoofReader.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: RufoofReader.PKCS5.PBKDF1.Error, b: RufoofReader.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: RufoofReader.PKCS5.PBKDF1.Variant, b: RufoofReader.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: RufoofReader.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: RufoofReader.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
    public func callAsFunction() -> Swift.Array<Swift.UInt8>
  }
}
extension RufoofReader.CS.BigUInt : Swift.Comparable {
  public static func compare(_ a: RufoofReader.CS.BigUInt, _ b: RufoofReader.CS.BigUInt) -> Foundation.ComparisonResult
  public static func == (a: RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt) -> Swift.Bool
  public static func < (a: RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt) -> Swift.Bool
}
extension RufoofReader.CS.BigInt {
  public static func == (a: RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt) -> Swift.Bool
  public static func < (a: RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt) -> Swift.Bool
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
@_hasMissingDesignatedInitializers public class BookFilesHelper {
  public static var toc: [RufoofReader.RRTOCItem]
  public static var index1: [Swift.String : Any]
  public static var index2: [Swift.String : Any]
  public static func getBookPath(bookId: Swift.Int) -> Foundation.URL
  public static func getPDFFilePath() -> Foundation.URL
  public static func getChapterAndSpans(bookId: Swift.Int, forChapterNumber number: Swift.Int, formatVersion: Swift.Int?) -> (html: Swift.String, spans: Swift.String)
  public static func getBookInfoFile(bookId: Swift.Int) -> RufoofReader.RRBookInfoModel
  public static func getPDFBookInfoFile() -> RufoofReader.RRBookInfoModel
  public static func getBookToc(bookId: Swift.Int, formatVersion: Swift.Int?) -> [RufoofReader.RRTOCItem]
  public static func getLocationsFile(bookId: Swift.Int, formatVersion: Swift.Int?) -> [Swift.String : Any]?
  public static func getPagesFile(bookId: Swift.Int, formatVersion: Swift.Int?) -> [Swift.Int]?
  public static func getSyncFile(bookId: Swift.Int, formatVersion: Swift.Int?, chaptersCount: Swift.Int) -> [[[Swift.Int]]]
  public static func getChapterIndex(offset: Swift.Int) -> Swift.Int
  public static func getChapterAndPageIndex(offset: Swift.Int, chapters: [RufoofReader.RRChapterItem]) -> (pageNumber: Swift.Int, chapterNumber: Swift.Int)
  public static func isAttr(charIndex: Swift.Int, textView: UIKit.UITextView) -> Swift.Bool
  public static func isAttrLink(charIndex: Swift.Int, textView: UIKit.UITextView) -> Swift.String
  public static func isAttrLink(length: Swift.Int, startLocation: Swift.Int, attr: Foundation.NSAttributedString) -> Swift.String
  public static func boundingRectForCharacterRange(range: Foundation.NSRange, textView: UIKit.UITextView) -> CoreFoundation.CGRect?
  public static func getSyncAudioChapter(bookId: Swift.Int, fileName: Swift.String, formatVersion: Swift.Int? = 0, completion: @escaping (Foundation.Data?) -> ())
  public static func getBookPageIndex(chapterIndex: Swift.Int, pageIndex: Swift.Int, chapters: [RufoofReader.RRChapterItem]) -> Swift.Int
  public static func getChapterFromPageIndex(pageIndex: Swift.Int, chapters: [RufoofReader.RRChapterItem]) -> (chapterIndex: Swift.Int, pageIndex: Swift.Int)
  public static func getPageIndexAndChapterPagesCount(chapterIndex: Swift.Int, pageIndex: Swift.Int, chapters: [RufoofReader.RRChapterItem]) -> (pageIndex: Swift.Int, pagesCount: Swift.Int)
  public static func getPageIndexFromPagesFile(currentOffset: Swift.Int, pages: [Swift.Int]) -> Swift.Int
  public static func sortBooks(books: [RufoofReader.RRBookDataModel]) -> [RufoofReader.RRBookDataModel]
  public static func readingTimeSort(books: [RufoofReader.RRBookDataModel]) -> [RufoofReader.RRBookDataModel]
  public static func dateAddedSort(books: [RufoofReader.RRBookDataModel]) -> [RufoofReader.RRBookDataModel]
  public static func checkBookFileIfExist(bookId: Swift.Int) -> Swift.Bool
  public static func checkOffline(bookId: Swift.Int) -> Swift.Bool
  public static func getBookIndex(_ lookupWord: Swift.String, bookId: Swift.Int, isEnglish: Swift.Bool, formatVersion: Swift.Int? = 0, callback: @escaping ([Swift.String : Any]?, Swift.Int?) -> ())
  @objc deinit
}
extension RufoofReader.CS.BigUInt {
  public func greatestCommonDivisor(with b: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public func inverse(_ modulus: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt?
}
extension RufoofReader.CS.BigInt {
  public func greatestCommonDivisor(with b: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public func inverse(_ modulus: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt?
}
public struct ECB : RufoofReader.BlockMode {
  public let options: RufoofReader.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
}
public let appleLanguagesKey: Swift.String
public enum Language : Swift.String {
  case english
  case arabic
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: RufoofReader.Blowfish.Error, b: RufoofReader.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any RufoofReader.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: RufoofReader.Padding) throws
  @objc deinit
}
extension RufoofReader.Blowfish : RufoofReader.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public typealias FILEPointer = Swift.UnsafeMutablePointer<Darwin.FILE>
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public var isPanModalPresented: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public func presentPanModal(_ viewControllerToPresent: any UIKit.UIViewController & RufoofReader.RRPanModalPresentable, sourceView: UIKit.UIView? = nil, sourceRect: CoreFoundation.CGRect = .zero)
}
extension RufoofReader.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: RufoofReader.PKCS5.PBKDF2.Error, b: RufoofReader.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: RufoofReader.HMAC.Variant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
    public func callAsFunction() throws -> Swift.Array<Swift.UInt8>
  }
}
@objc open class JukeboxItem : ObjectiveC.NSObject {
  public struct Meta {
    public var duration: Swift.Double? {
      get
    }
    public var title: Swift.String? {
      get
    }
    public var album: Swift.String? {
      get
    }
    public var artist: Swift.String? {
      get
    }
    public var artwork: UIKit.UIImage? {
      get
    }
  }
  open var localTitle: Swift.String?
  open var playerItem: AVFoundation.AVPlayerItem? {
    get
  }
  open var currentTime: Swift.Double?
  open var meta: RufoofReader.JukeboxItem.Meta {
    get
  }
  required public init(URL: Foundation.URL, localTitle: Swift.String? = nil)
  @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @objc deinit
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
}
public enum KVStorageType {
  case file, sqlite, automatic
  public static func == (a: RufoofReader.KVStorageType, b: RufoofReader.KVStorageType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RRResultHolder : Swift.Comparable {
  public var start: Swift.Int
  public var length: Swift.Int
  public var chapterNumber: Swift.Int
  public var words: [Swift.String]
  public var positions: [Swift.Int]
  public var previewText: Foundation.NSMutableAttributedString
  public var previewLocation: Swift.String
  public init(word: Swift.String, start: Swift.Int, chapterNumber: Swift.Int)
  open func getStart() -> Swift.Int
  open func setPreviewText(_ previewText: Foundation.NSMutableAttributedString)
  open func setPreviewLocation(_ previewLocation: Swift.String)
  public static func < (lhs: RufoofReader.RRResultHolder, rhs: RufoofReader.RRResultHolder) -> Swift.Bool
  public static func == (lhs: RufoofReader.RRResultHolder, rhs: RufoofReader.RRResultHolder) -> Swift.Bool
  @objc deinit
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension RufoofReader.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
public typealias LonginusSetImageBlock = (UIKit.UIImage?) -> Swift.Void
public typealias LonginusSetShowTransitionBlock = (UIKit.UIImage?) -> Swift.Void
public let LonginusImageFadeAnimationKey: Swift.String
public protocol ImageWebCacheable : AnyObject {
  func setImage(with resource: (any RufoofReader.ImageWebCacheResourceable)?, placeholder: UIKit.UIImage?, options: RufoofReader.LonginusImageOptions?, transformer: RufoofReader.ImageTransformer?, taskKey: Swift.String, setShowTransition: @escaping RufoofReader.LonginusSetShowTransitionBlock, setImage: @escaping RufoofReader.LonginusSetImageBlock, progress: RufoofReader.ImageDownloaderProgressBlock?, completion: RufoofReader.ImageManagerCompletionBlock?)
}
extension RufoofReader.ImageWebCacheable {
  public var webCacheOperation: RufoofReader.ImageWebCacheOperation {
    get
  }
  public func setImage(with resource: (any RufoofReader.ImageWebCacheResourceable)?, placeholder: UIKit.UIImage?, options: RufoofReader.LonginusImageOptions?, transformer: RufoofReader.ImageTransformer?, taskKey: Swift.String, setShowTransition: @escaping RufoofReader.LonginusSetShowTransitionBlock, setImage: @escaping RufoofReader.LonginusSetImageBlock, progress: RufoofReader.ImageDownloaderProgressBlock?, completion: RufoofReader.ImageManagerCompletionBlock?)
}
public class ImageWebCacheOperation {
  public init()
  public func task(forKey key: Swift.String) -> RufoofReader.ImageLoadTask?
  public func setTask(_ task: RufoofReader.ImageLoadTask, forKey key: Swift.String)
  public func downloadProgress(forKey key: Swift.String) -> Swift.Double
  public func setDownloadProgress(_ downloadProgress: Swift.Double, forKey key: Swift.String)
  @objc deinit
}
public let LonginusPrefixID: Swift.String
public let lg_shareColorSpace: CoreGraphics.CGColorSpace
public let lg_ScreenScale: CoreFoundation.CGFloat
public protocol LonginusCompatible {
}
public struct LonginusExtension<Base> {
  public let base: Base
  public init(_ base: Base)
}
extension RufoofReader.LonginusCompatible {
  public var lg: RufoofReader.LonginusExtension<Self> {
    get
    set
  }
}
extension UIKit.UIImage : RufoofReader.LonginusCompatible {
}
extension UIKit.UIView : RufoofReader.LonginusCompatible {
}
extension CoreGraphics.CGImage : RufoofReader.LonginusCompatible {
}
extension QuartzCore.CALayer : RufoofReader.LonginusCompatible {
}
extension Swift.String : RufoofReader.LonginusCompatible {
}
extension Foundation.Data : RufoofReader.LonginusCompatible {
}
extension UIKit.UIImage.Orientation : RufoofReader.LonginusCompatible {
}
extension ImageIO.CGImagePropertyOrientation : RufoofReader.LonginusCompatible {
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: RufoofReader.BlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: RufoofReader.BlockModeOption
  @usableFromInline
  internal static let paddingRequired: RufoofReader.BlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: RufoofReader.BlockModeOption
  public typealias ArrayLiteralElement = RufoofReader.BlockModeOption
  public typealias Element = RufoofReader.BlockModeOption
  public typealias RawValue = Swift.Int
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : RufoofReader.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func encrypt(cipher: any RufoofReader.Cipher, _ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
public class MemoryCache<Key, Value> where Key : Swift.Hashable {
  public typealias OperationBlock = (_ cache: RufoofReader.MemoryCache<Key, Value>) -> Swift.Void
  public var totalCount: Swift.Int {
    get
  }
  public var totalCost: Swift.Int {
    get
  }
  public var first: Value? {
    get
  }
  public var last: Value? {
    get
  }
  public var countLimit: Swift.Int32 {
    get
    set
  }
  public var costLimit: Swift.Int32 {
    get
    set
  }
  public var ageLimit: RufoofReader.CacheAge {
    get
    set
  }
  public var autoTrimInterval: Foundation.TimeInterval {
    get
    set
  }
  public var shouldremoveAllValuesOnMemoryWarning: Swift.Bool
  public var shouldremoveAllValuesWhenEnteringBackground: Swift.Bool
  public var didReceiveMemoryWarningBlock: RufoofReader.MemoryCache<Key, Value>.OperationBlock?
  public var didEnterBackgroundBlock: RufoofReader.MemoryCache<Key, Value>.OperationBlock?
  public var releaseOnMainThread: Swift.Bool
  public init(countLimit: Swift.Int32 = Int32.max, costLimit: Swift.Int32 = Int32.max, ageLimit: RufoofReader.CacheAge = .never, autoTrimInterval: Foundation.TimeInterval = 5)
  @objc deinit
}
extension RufoofReader.MemoryCache : RufoofReader.MemoryCacheable {
  public func containsObject(key: Key) -> Swift.Bool
  public func query(key: Key) -> Value?
  public func save(value: Value?, for key: Key)
  public func save(_ dataWork: @escaping () -> (Value, Swift.Int)?, forKey key: Key)
  public func save(value: Value?, for key: Key, cost: Swift.Int = 0)
  public func remove(key: Key)
  public func removeAll()
}
extension RufoofReader.MemoryCache {
  public func trimToCount(_ count: Swift.Int32)
  public func trimToCost(_ cost: Swift.Int32)
  public func trimToAge(_ age: RufoofReader.CacheAge)
}
public protocol RRReaderViewDelegate {
  func onStyleChanged(style: RufoofReader.ReaderStyle)
  func onPositionChanged(position: Swift.Int)
  func onBookDetailsCLicked()
  func onSaveBookClicked(position: Swift.Int)
  func onShareBook()
  func onDownloadBook()
  func onSyncNotesAndMarks(list: [RufoofReader.NotesAndMarks])
  func onSyncReadingSession(session: RufoofReader.RRReadingSession)
  func onReaderClosed(position: Swift.Int)
  func onEndOfSample()
}
extension RufoofReader.CS.BigUInt {
  public static func >>= <Other>(lhs: inout RufoofReader.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout RufoofReader.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: RufoofReader.CS.BigUInt, rhs: Other) -> RufoofReader.CS.BigUInt where Other : Swift.BinaryInteger
  public static func << <Other>(lhs: RufoofReader.CS.BigUInt, rhs: Other) -> RufoofReader.CS.BigUInt where Other : Swift.BinaryInteger
}
extension RufoofReader.CS.BigInt {
  public static func &<< (left: RufoofReader.CS.BigInt, right: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func &<<= (left: inout RufoofReader.CS.BigInt, right: RufoofReader.CS.BigInt)
  public static func &>> (left: RufoofReader.CS.BigInt, right: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func &>>= (left: inout RufoofReader.CS.BigInt, right: RufoofReader.CS.BigInt)
  public static func << <Other>(lhs: RufoofReader.CS.BigInt, rhs: Other) -> RufoofReader.CS.BigInt where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout RufoofReader.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: RufoofReader.CS.BigInt, rhs: Other) -> RufoofReader.CS.BigInt where Other : Swift.BinaryInteger
  public static func >>= <Other>(lhs: inout RufoofReader.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
}
@available(iOS 10.0, *)
final public class UnfairLock {
  @usableFromInline
  final internal var _lock: Swift.UnsafeMutablePointer<Darwin.os_unfair_lock> {
    get
  }
  public init()
  @objc deinit
}
@available(iOS 10.0, *)
extension RufoofReader.UnfairLock {
  @inlinable final public func lock() { os_unfair_lock_lock(_lock) }
  @inlinable final public func unlock() { os_unfair_lock_unlock(_lock) }
}
@available(iOS 10.0, *)
extension RufoofReader.UnfairLock {
  @inlinable final public func trylock() -> Swift.Bool { os_unfair_lock_trylock(_lock) }
}
@available(iOS 10.0, *)
extension RufoofReader.UnfairLock {
  @inlinable final public func trySync<R>(_ block: () throws -> R) rethrows -> R? {
    guard trylock() else  { return nil }
    defer { unlock() }
    return try block()
  }
  @inlinable final public func sync<R>(_ block: () throws -> R) rethrows -> R {
    lock()
    defer { unlock() }
    return try block()
  }
}
@available(iOS 10.0, *)
extension RufoofReader.UnfairLock {
  public enum Predicate {
    case onThreadOwner
    case notOnThreadOwner
    public static func == (a: RufoofReader.UnfairLock.Predicate, b: RufoofReader.UnfairLock.Predicate) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 10.0, *)
extension RufoofReader.UnfairLock {
  @inlinable final public func precondition(condition: RufoofReader.UnfairLock.Predicate) {
    if condition == .onThreadOwner {
      os_unfair_lock_assert_owner(_lock)
    } else {
      os_unfair_lock_assert_not_owner(_lock)
    }
  }
}
public enum SignatureError : Swift.Error {
  case sign
  case verify
  public static func == (a: RufoofReader.SignatureError, b: RufoofReader.SignatureError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Signature : AnyObject {
  var keySize: Swift.Int { get }
  func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
extension RufoofReader.Signature {
  public func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class VerticalSlider : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) final public let slider: UIKit.UISlider
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc required override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var ascending: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var minimumValue: Swift.Float {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var maximumValue: Swift.Float {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var value: Swift.Float {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var thumbTintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var minimumTrackTintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var maximumTrackTintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var isContinuous: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func addTarget(_ target: Any?, action: ObjectiveC.Selector, for controlEvents: UIKit.UIControl.Event)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func removeTarget(_ target: Any?, action: ObjectiveC.Selector?, for controlEvents: UIKit.UIControl.Event)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DRM {
  public func create() -> (success: Swift.Bool, error: Swift.String?)
  @objc deinit
}
public typealias BigInteger = RufoofReader.CS.BigInt
public typealias BigUInteger = RufoofReader.CS.BigUInt
public enum CS {
}
@usableFromInline
final internal class StreamEncryptor : RufoofReader.Cryptor, RufoofReader.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any RufoofReader.CipherModeWorker
  @usableFromInline
  final internal let padding: RufoofReader.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RufoofReader.Padding, _ worker: any RufoofReader.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension RufoofReader.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <BaseCollection>(lhs: RufoofReader.BatchedCollectionIndex<BaseCollection>, rhs: RufoofReader.BatchedCollectionIndex<BaseCollection>) -> Swift.Bool where BaseCollection : Swift.Collection
  @usableFromInline
  internal static func < <BaseCollection>(lhs: RufoofReader.BatchedCollectionIndex<BaseCollection>, rhs: RufoofReader.BatchedCollectionIndex<BaseCollection>) -> Swift.Bool where BaseCollection : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = RufoofReader.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: RufoofReader.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: RufoofReader.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: RufoofReader.BatchedCollection<Base>.Index) -> RufoofReader.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: RufoofReader.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<RufoofReader.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<RufoofReader.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<RufoofReader.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> RufoofReader.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
@_hasMissingDesignatedInitializers public class ImageCacher {
  final public let memoryCache: RufoofReader.MemoryCache<Swift.String, UIKit.UIImage>
  final public let diskCache: RufoofReader.DiskCache?
  weak public var imageCoder: (any RufoofReader.ImageCodeable)?
  public func removeAll()
  public func removeAll(_ completion: @escaping () -> Swift.Void)
  @objc deinit
}
extension RufoofReader.ImageCacher : RufoofReader.ImageCacheable {
  public func image(forKey key: Swift.String, cacheType: RufoofReader.ImageCacheType, completion: @escaping (RufoofReader.ImageCacheQueryCompletionResult) -> Swift.Void)
  public func isCached(forKey key: Swift.String) -> (Swift.Bool, RufoofReader.ImageCacheType)
  public func diskDataExists(forKey key: Swift.String, completion: ((Swift.Bool) -> Swift.Void)?)
  public func store(_ image: UIKit.UIImage?, data: Foundation.Data?, forKey key: Swift.String, cacheType: RufoofReader.ImageCacheType, completion: (() -> Swift.Void)?)
  public func removeImage(forKey key: Swift.String, cacheType: RufoofReader.ImageCacheType, completion: ((Swift.String) -> Swift.Void)?)
  public func remove(_ type: RufoofReader.ImageCacheType, completion: (() -> Swift.Void)?)
}
extension RufoofReader.CS.BigUInt {
  public static func randomInteger<RNG>(withMaximumWidth width: Swift.Int, using generator: inout RNG) -> RufoofReader.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withMaximumWidth width: Swift.Int) -> RufoofReader.CS.BigUInt
  public static func randomInteger<RNG>(withExactWidth width: Swift.Int, using generator: inout RNG) -> RufoofReader.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withExactWidth width: Swift.Int) -> RufoofReader.CS.BigUInt
  public static func randomInteger<RNG>(lessThan limit: RufoofReader.CS.BigUInt, using generator: inout RNG) -> RufoofReader.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(lessThan limit: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
}
public struct PageAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public var scaleRate: CoreFoundation.CGFloat
  public init(scaleRate: CoreFoundation.CGFloat = 0.2)
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
extension RufoofReader.CS.BigUInt {
  public static func + (a: RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public static func += (a: inout RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt)
}
extension RufoofReader.CS.BigInt {
  public static func + (a: RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func += (a: inout RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt)
}
extension RufoofReader.CS.BigUInt {
  public func isStrongProbablePrime(_ base: RufoofReader.CS.BigUInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension RufoofReader.CS.BigInt {
  public func isStrongProbablePrime(_ base: RufoofReader.CS.BigInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension RufoofReader.RSA : RufoofReader.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.encrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func encrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: RufoofReader.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Prepare the data for the specified variant
    let preparedData = try variant.prepare(bytes, blockSize: self.keySizeBytes)

    // Encrypt the prepared data
    return try variant.formatEncryptedBytes(self.encryptPreparedBytes(preparedData), blockSize: self.keySizeBytes)
  }
  @inlinable final internal func encryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Calculate encrypted data
    return BigUInteger(Data(bytes)).power(self.e, modulus: self.n).serialize().bytes
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.decrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func decrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: RufoofReader.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Decrypt the data
    let decrypted = try self.decryptPreparedBytes(bytes)

    // Remove padding / unstructure data and return the raw plaintext
    return variant.removePadding(decrypted, blockSize: self.keySizeBytes)
  }
  @inlinable final internal func decryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Check for Private Exponent presence
    guard let d = d else { throw RSA.Error.noPrivateKey }

    // Calculate decrypted data
    return BigUInteger(Data(bytes)).power(d, modulus: self.n).serialize().bytes
  }
}
extension RufoofReader.RSA {
  @frozen public enum RSAEncryptionVariant {
    case unsafe
    case raw
    case pksc1v15
    @inlinable internal func prepare(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) throws -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          // We need at least 11 bytes of padding in order to safely encrypt messages
          // - block types 1 and 2 have this minimum padding requirement, block type 0 isn't specified, but we enforce the minimum padding length here to be safe.
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Array(repeating: 0x00, count: blockSize - bytes.count) + bytes
        case .pksc1v15:
          // The `Security` framework refuses to encrypt a zero byte message using the pkcs1v15 padding scheme, so we do the same
          guard !bytes.isEmpty else { throw RSA.Error.invalidMessageLengthForEncryption }
          // We need at least 11 bytes of random padding in order to safely encrypt messages (RFC2313 Section 8.1 - Note 6)
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Padding.eme_pkcs1v15.add(to: bytes, blockSize: blockSize)
      }
    }
    @inlinable internal func formatEncryptedBytes(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw, .pksc1v15:
          // Format the encrypted bytes before returning
          return Array<UInt8>(repeating: 0x00, count: blockSize - bytes.count) + bytes
      }
    }
    @inlinable internal func removePadding(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          return bytes
        case .pksc1v15:
          // Convert the Octet String into an Integer Primitive using the BigInteger `serialize` method
          // (this effectively just prefixes the data with a 0x00 byte indicating that its a positive integer)
          return Padding.eme_pkcs1v15.remove(from: [0x00] + bytes, blockSize: blockSize)
      }
    }
    public static func == (a: RufoofReader.RSA.RSAEncryptionVariant, b: RufoofReader.RSA.RSAEncryptionVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct SnapInAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public init()
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RufoofReader.CTR.Error, b: RufoofReader.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: RufoofReader.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
}
public struct Semaphore {
  public init(poolSize: Swift.Int = 0)
  @discardableResult
  public func wait(_ timeout: Dispatch.DispatchTime = .distantFuture) -> Dispatch.DispatchTimeoutResult
  @discardableResult
  public func `continue`() -> Swift.Int
}
extension RufoofReader.CS.BigUInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RufoofReader.CS.BigInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RufoofReader.LonginusExtension where Base : UIKit.UIImage {
  public var cgImage: CoreGraphics.CGImage? {
    get
  }
  public var size: CoreFoundation.CGSize {
    get
  }
  public var scale: CoreFoundation.CGFloat {
    get
  }
  public var bytes: Swift.Int64 {
    get
  }
  public var imageFormat: RufoofReader.ImageFormat? {
    get
    set
  }
  public var lgImageEditKey: Swift.String? {
    get
    set
  }
}
extension RufoofReader.LonginusExtension where Base : CoreGraphics.CGImage {
  public var containsAlpha: Swift.Bool {
    get
  }
}
extension RufoofReader.LonginusExtension where Base == UIKit.UIImage.Orientation {
  public var cgImageOrientation: ImageIO.CGImagePropertyOrientation {
    get
  }
}
extension RufoofReader.LonginusExtension where Base == ImageIO.CGImagePropertyOrientation {
  public var uiImageOrientation: UIKit.UIImage.Orientation {
    get
  }
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int64 { get }
}
extension UIKit.UIImage : RufoofReader.CacheCostCalculable {
  public var cacheCost: Swift.Int64 {
    get
  }
}
extension RufoofReader.HMAC {
  convenience public init(key: Swift.String, variant: RufoofReader.HMAC.Variant = .md5) throws
}
@_hasMissingDesignatedInitializers public class RRChapterItem {
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
public typealias Async = RufoofReader.AsyncBlock<Swift.Void, Swift.Void>
public struct AsyncBlock<In, Out> {
  @discardableResult
  public static func main<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> RufoofReader.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func userInteractive<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> RufoofReader.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func userInitiated<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> RufoofReader.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func utility<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> RufoofReader.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func background<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> RufoofReader.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func custom<O>(queue: Dispatch.DispatchQueue, after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> RufoofReader.AsyncBlock<Swift.Void, O>
  @discardableResult
  public func main<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> RufoofReader.AsyncBlock<Out, O>
  @discardableResult
  public func userInteractive<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> RufoofReader.AsyncBlock<Out, O>
  @discardableResult
  public func userInitiated<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> RufoofReader.AsyncBlock<Out, O>
  @discardableResult
  public func utility<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> RufoofReader.AsyncBlock<Out, O>
  @discardableResult
  public func background<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> RufoofReader.AsyncBlock<Out, O>
  @discardableResult
  public func custom<O>(queue: Dispatch.DispatchQueue, after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> RufoofReader.AsyncBlock<Out, O>
  public func cancel()
  @discardableResult
  public func wait(seconds: Swift.Double? = nil) -> Dispatch.DispatchTimeoutResult
}
public struct Apply {
  public static func userInteractive(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func userInitiated(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func utility(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func background(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func custom(queue: Dispatch.DispatchQueue, iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
}
public struct AsyncGroup {
  public init()
  public func enter()
  public func leave()
  public func main(_ block: @escaping @convention(block) () -> Swift.Void)
  public func userInteractive(_ block: @escaping @convention(block) () -> Swift.Void)
  public func userInitiated(_ block: @escaping @convention(block) () -> Swift.Void)
  public func utility(_ block: @escaping @convention(block) () -> Swift.Void)
  public func background(_ block: @escaping @convention(block) () -> Swift.Void)
  public func custom(queue: Dispatch.DispatchQueue, block: @escaping @convention(block) () -> Swift.Void)
  @discardableResult
  public func wait(seconds: Swift.Double? = nil) -> Dispatch.DispatchTimeoutResult
}
extension Darwin.qos_class_t {
  public var description: Swift.String {
    get
  }
}
extension Dispatch.DispatchQoS.QoSClass {
  public var description: Swift.String {
    get
  }
}
extension RufoofReader.CS.BigUInt {
  prefix public static func ~ (a: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public static func |= (a: inout RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt)
  public static func &= (a: inout RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt)
  public static func ^= (a: inout RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt)
}
extension RufoofReader.CS.BigInt {
  prefix public static func ~ (x: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func & (lhs: inout RufoofReader.CS.BigInt, rhs: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func | (lhs: inout RufoofReader.CS.BigInt, rhs: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func ^ (lhs: inout RufoofReader.CS.BigInt, rhs: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func &= (lhs: inout RufoofReader.CS.BigInt, rhs: RufoofReader.CS.BigInt)
  public static func |= (lhs: inout RufoofReader.CS.BigInt, rhs: RufoofReader.CS.BigInt)
  public static func ^= (lhs: inout RufoofReader.CS.BigInt, rhs: RufoofReader.CS.BigInt)
}
extension RufoofReader.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
extension RufoofReader.CS.BigUInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension RufoofReader.CS.BigInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: RufoofReader.Rabbit.Error, b: RufoofReader.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension RufoofReader.Rabbit : RufoofReader.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class RRPanContainerView : UIKit.UIView {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class SynchronousOperation : RufoofReader.ConcurrentOperation {
  @objc override dynamic public var isAsynchronous: Swift.Bool {
    @objc get
  }
  override public func finish(success: Swift.Bool = true)
  @objc override dynamic public func cancel()
  override public func execute()
  override public init(name: Swift.String? = nil, executionBlock: ((_ operation: RufoofReader.ConcurrentOperation) -> Swift.Void)? = nil)
  @objc deinit
}
extension RufoofReader.XChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class RRMiniAudioPlayer : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func setBookData(bookData data: RufoofReader.RRReaderBookData)
  @_Concurrency.MainActor(unsafe) public func setBookId(bookId id: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setBookTitle(bookTitle title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setupBackground(image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func fixSkipTime()
  @objc deinit
}
public class DispatchQueuePool {
  public static let DispatchPoolPrefixID: Swift.String
  public static let userInteractive: RufoofReader.DispatchQueuePool
  public static let `default`: RufoofReader.DispatchQueuePool
  public static let userInitiated: RufoofReader.DispatchQueuePool
  public static let utility: RufoofReader.DispatchQueuePool
  public static let background: RufoofReader.DispatchQueuePool
  public var currentQueue: Dispatch.DispatchQueue {
    get
  }
  public static let fitableMaxQueueCount: Swift.Int
  public init(label: Swift.String, qos: Dispatch.DispatchQoS, queueCount: Swift.Int = 0)
  public func async(work: @escaping () -> Swift.Void)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CBCMAC : RufoofReader.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension RufoofReader.Archive {
  final public var data: Foundation.Data? {
    get
  }
}
public struct CubeAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public var perspective: CoreFoundation.CGFloat
  public var totalAngle: CoreFoundation.CGFloat
  public init(perspective: CoreFoundation.CGFloat = -1 / 500, totalAngle: CoreFoundation.CGFloat = .pi / 2)
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
final public class GCM : RufoofReader.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: RufoofReader.GCM.Mode, b: RufoofReader.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: RufoofReader.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: RufoofReader.GCM.Error, b: RufoofReader.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: RufoofReader.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: RufoofReader.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
  @objc deinit
}
public protocol RRAudioPlayerReaderDelegate {
  func onPairFound(pair: [Swift.Int], chapter: Swift.Int)
  func onShowPlayLoading()
  func onStartPlaying()
  func onPausePlaying()
  func onGotoPosition(position: Swift.Int)
  func onGotoAudioPosition(chapter: Swift.Int, position: Swift.Int)
  func onGotoChapter(index: Swift.Int)
  func onUpdateRate()
  func onDownloadBook()
  func onReSync()
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> any RufoofReader.Cryptor & RufoofReader.Updatable
  func makeDecryptor() throws -> any RufoofReader.Cryptor & RufoofReader.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension RufoofReader.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
@objc public class LonginusWeakProxy : ObjectiveC.NSObject {
  public init(target: any ObjectiveC.NSObjectProtocol)
  @objc override dynamic public func responds(to aSelector: ObjectiveC.Selector!) -> Swift.Bool
  @objc override dynamic public func forwardingTarget(for aSelector: ObjectiveC.Selector!) -> Any?
  @objc deinit
}
@available(*, renamed: "Digest")
public typealias Hash = RufoofReader.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: RufoofReader.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: RufoofReader.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
extension RufoofReader.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
}
extension RufoofReader.CS.BigInt {
  public init()
  public init(_ integer: RufoofReader.CS.BigUInt)
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
}
extension RufoofReader.CS.BigUInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.UInt64)
  public typealias IntegerLiteralType = Swift.UInt64
}
extension RufoofReader.CS.BigInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int64)
  public typealias IntegerLiteralType = Swift.Int64
}
public class RRBookInfo {
  final public let length: Swift.Int
  final public let formatVersion: Swift.Int
  public var type: Swift.String
  final public let pages: Swift.Int
  final public let isSample: Swift.Bool
  final public let hasAudioSync: Swift.Bool
  public init()
  public init(data: [Swift.String : Any])
  public init(bookInfoModel: RufoofReader.RRBookInfoModel)
  @objc deinit
}
public struct RotateInOutAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public var minAlpha: CoreFoundation.CGFloat
  public var maxRotate: CoreFoundation.CGFloat
  public init(minAlpha: CoreFoundation.CGFloat = 0, maxRotate: CoreFoundation.CGFloat = .pi / 4)
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
public struct RRSwiftData {
  public static func executeChange(_ sqlStr: Swift.String) -> Swift.Int?
  public static func executeChange(_ sqlStr: Swift.String, withArgs: [Any]) -> Swift.Int?
  public static func executeMultipleChanges(_ sqlArr: [Swift.String]) -> Swift.Int?
  public static func executeQuery(_ sqlStr: Swift.String) -> (result: [RufoofReader.RRSwiftData.SDRow], error: Swift.Int?)
  public static func executeQuery(_ sqlStr: Swift.String, withArgs: [Any]) -> (result: [RufoofReader.RRSwiftData.SDRow], error: Swift.Int?)
  public static func executeWithConnection(_ flags: RufoofReader.SD.Flags, closure: @escaping () -> Swift.Void) -> Swift.Int?
  public static func escapeValue(_ obj: Any?) -> Swift.String
  public static func escapeIdentifier(_ obj: Swift.String) -> Swift.String
  public static func createTable(_ table: Swift.String, withColumnNamesAndTypes values: [Swift.String : RufoofReader.RRSwiftData.DataType]) -> Swift.Int?
  public static func deleteTable(_ table: Swift.String) -> Swift.Int?
  public static func existingTables() -> (result: [Swift.String], error: Swift.Int?)
  public static func errorMessageForCode(_ code: Swift.Int) -> Swift.String
  public static func databasePath() -> Swift.String
  public static func lastInsertedRowID() -> (rowID: Swift.Int, error: Swift.Int?)
  public static func numberOfRowsModified() -> (rowID: Swift.Int, error: Swift.Int?)
  public static func createIndex(name: Swift.String, onColumns: [Swift.String], inTable: Swift.String, isUnique: Swift.Bool = false) -> Swift.Int?
  public static func removeIndex(_ indexName: Swift.String) -> Swift.Int?
  public static func existingIndexes() -> (result: [Swift.String], error: Swift.Int?)
  public static func existingIndexesForTable(_ table: Swift.String) -> (result: [Swift.String], error: Swift.Int?)
  public static func transaction(_ transactionClosure: @escaping () -> Swift.Bool) -> Swift.Int?
  public static func savepoint(_ savepointClosure: @escaping () -> Swift.Bool) -> Swift.Int?
  public static func saveUIImage(_ image: UIKit.UIImage) -> Swift.String?
  public static func deleteUIImageWithID(_ id: Swift.String) -> Swift.Bool
  public struct SDRow {
    public subscript(key: Swift.String) -> RufoofReader.RRSwiftData.SDColumn? {
      get
      set(newValue)
    }
  }
  public struct SDColumn {
    public func asString() -> Swift.String?
    public func asInt() -> Swift.Int?
    public func asDouble() -> Swift.Double?
    public func asBool() -> Swift.Bool?
    public func asData() -> Foundation.Data?
    public func asDate() -> Foundation.Date?
    public func asAnyObject() -> Any?
    public func asUIImage() -> UIKit.UIImage?
  }
}
extension RufoofReader.RRSwiftData {
  public enum DataType {
    case stringVal
    case intVal
    case doubleVal
    case boolVal
    case dataVal
    case dateVal
    case uiImageVal
    public static func == (a: RufoofReader.RRSwiftData.DataType, b: RufoofReader.RRSwiftData.DataType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Flags {
    case readOnly
    case readWrite
    case readWriteCreate
    public static func == (a: RufoofReader.RRSwiftData.Flags, b: RufoofReader.RRSwiftData.Flags) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public typealias SD = RufoofReader.RRSwiftData
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers public class FileHelper {
  public static func getBooksFolderPath() -> Foundation.URL
  public static func getFilePath(name: Swift.String) -> Foundation.URL
  public static func getDocumentsDirectory() -> Foundation.URL
  @objc deinit
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: RufoofReader.AES.Error, b: RufoofReader.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: RufoofReader.AES.Variant
  @usableFromInline
  final internal let blockMode: any RufoofReader.BlockMode
  @usableFromInline
  final internal let padding: RufoofReader.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any RufoofReader.BlockMode, padding: RufoofReader.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension RufoofReader.AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension RufoofReader.AES : RufoofReader.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
extension RufoofReader.LonginusExtension where Base == Foundation.Data {
  public var imageFormat: RufoofReader.ImageFormat {
    get
  }
  public func contains(jpeg marker: RufoofReader.ImageFormat.JPEGMarker) -> Swift.Bool
}
public class NotesAndMarks {
  public var bookId: Swift.Int
  public var fromOffset: Swift.Int
  public var toOffset: Swift.Int
  public var markColor: Swift.Int?
  public var displayText: Swift.String?
  public var type: Swift.Int
  public var deleted: Swift.Int?
  public var local: Swift.Int?
  public init(bookId: Swift.Int, fromOffset: Swift.Int, toOffset: Swift.Int, markColor: Swift.Int?, displayText: Swift.String?, type: Swift.Int, deleted: Swift.Int?, local: Swift.Int?)
  public init(data: [Swift.String : Any])
  public init(dbData: [Swift.String : Any])
  @objc deinit
}
extension UIKit.UIDevice : RufoofReader.LonginusCompatible {
}
extension RufoofReader.LonginusExtension where Base : UIKit.UIDevice {
  public static var totalMemory: Swift.Int64 {
    get
  }
  public static var freeMemory: Swift.Int64 {
    get
  }
}
@_hasMissingDesignatedInitializers public class RRPageItem {
  @objc deinit
}
final public class OCB : RufoofReader.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: RufoofReader.OCB.Mode, b: RufoofReader.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: RufoofReader.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: RufoofReader.OCB.Error, b: RufoofReader.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: RufoofReader.OCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: RufoofReader.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
  @objc deinit
}
public struct ParallaxAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public var speed: CoreFoundation.CGFloat
  public init(speed: CoreFoundation.CGFloat = 0.5)
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
@_hasMissingDesignatedInitializers public class RRChapterBuilder {
  public func setFormatVersion(formatVersion format: Swift.Int)
  public func setTextSize(textSize size: CoreFoundation.CGFloat)
  public func setFontType(fontType font: Swift.Int)
  public func setTextAlignment(textAlignment alignment: UIKit.NSTextAlignment)
  public func setWritingDirection(writingDirection direction: UIKit.NSWritingDirection)
  public func setLineHeightMultiple(lineHeightMultiple lineHeight: CoreFoundation.CGFloat)
  public func rc4EncryptDecrypt(withData data: Foundation.Data) -> Foundation.Data
  public func rc4EncryptDecrypt(withData data: Foundation.Data, withKey key: Foundation.Data) -> Foundation.Data
  @objc deinit
}
extension RufoofReader.LonginusExtension where Base : UIKit.UIView {
  public enum FillContentMode {
    case center
    case top
    case bottom
    case left
    case right
    case topLeft
    case topRight
    case bottomLeft
    case bottomRight
    public static func == (a: RufoofReader.LonginusExtension<Base>.FillContentMode, b: RufoofReader.LonginusExtension<Base>.FillContentMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: RufoofReader.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
extension RufoofReader.Archive {
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func extract(_ entry: RufoofReader.Entry, to url: Foundation.URL, bufferSize: Swift.UInt32, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil) throws -> RufoofReader.CRC32
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func extract(_ entry: RufoofReader.Entry, bufferSize: Swift.UInt32, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> RufoofReader.CRC32
}
public class ImageGIFCoder {
  public var imageData: Foundation.Data? {
    get
    set
  }
  public var frameCount: Swift.Int? {
    get
  }
  public var loopCount: Swift.Int? {
    get
  }
  public init()
  @objc deinit
}
extension RufoofReader.ImageGIFCoder : RufoofReader.ImageCodeable {
  public func canDecode(_ data: Foundation.Data) -> Swift.Bool
  public func decodedImage(with data: Foundation.Data) -> UIKit.UIImage?
  public func decompressedImage(with image: UIKit.UIImage, data: Foundation.Data) -> UIKit.UIImage?
  public func canEncode(_ format: RufoofReader.ImageFormat) -> Swift.Bool
  public func encodedData(with image: UIKit.UIImage, format: RufoofReader.ImageFormat) -> Foundation.Data?
  public func copy() -> any RufoofReader.ImageCodeable
}
extension RufoofReader.ImageGIFCoder : RufoofReader.AnimatedImageCodeable {
  public var bytesPerFrame: Swift.Int64? {
    get
  }
  public func imageFrame(at index: Swift.Int, decompress: Swift.Bool) -> UIKit.UIImage?
  public func imageFrameSize(at index: Swift.Int) -> CoreFoundation.CGSize?
  public func duration(at index: Swift.Int) -> Foundation.TimeInterval?
}
extension RufoofReader.CS.BigUInt {
  public mutating func subtractReportingOverflow(_ b: RufoofReader.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> Swift.Bool
  public func subtractingReportingOverflow(_ other: RufoofReader.CS.BigUInt, shiftedBy shift: Swift.Int) -> (partialValue: RufoofReader.CS.BigUInt, overflow: Swift.Bool)
  public func subtractingReportingOverflow(_ other: RufoofReader.CS.BigUInt) -> (partialValue: RufoofReader.CS.BigUInt, overflow: Swift.Bool)
  public mutating func subtract(_ other: RufoofReader.CS.BigUInt, shiftedBy shift: Swift.Int = 0)
  public func subtracting(_ other: RufoofReader.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> RufoofReader.CS.BigUInt
  public mutating func decrement(shiftedBy shift: Swift.Int = 0)
  public static func - (a: RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public static func -= (a: inout RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt)
}
extension RufoofReader.CS.BigInt {
  public mutating func negate()
  public static func - (a: RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func -= (a: inout RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class RRPanModalPresentationController : UIKit.UIPresentationController {
  public enum PresentationState {
    case shortForm
    case longForm
    public static func == (a: RufoofReader.RRPanModalPresentationController.PresentationState, b: RufoofReader.RRPanModalPresentationController.PresentationState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var presentedView: UIKit.UIView {
    @objc get
  }
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func containerViewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func presentationTransitionWillBegin()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func presentationTransitionDidEnd(_ completed: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func dismissalTransitionWillBegin()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func dismissalTransitionDidEnd(_ completed: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(presentedViewController: UIKit.UIViewController, presenting presentingViewController: UIKit.UIViewController?)
}
extension RufoofReader.RRPanModalPresentationController {
  @_Concurrency.MainActor(unsafe) public func transition(to state: RufoofReader.RRPanModalPresentationController.PresentationState)
  @_Concurrency.MainActor(unsafe) public func performUpdates(_ updates: () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func setNeedsLayoutUpdate()
}
extension RufoofReader.RRPanModalPresentationController : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
final public class RSA {
  public enum Error : Swift.Error {
    case noPrivateKey
    case invalidInverseNotCoprimes
    case unsupportedRSAVersion
    case invalidPrimes
    case noPrimes
    case unableToCalculateCoefficient
    case invalidSignatureLength
    case invalidMessageLengthForSigning
    case invalidMessageLengthForEncryption
    case invalidDecryption
    public static func == (a: RufoofReader.RSA.Error, b: RufoofReader.RSA.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let n: RufoofReader.BigUInteger
  final public let e: RufoofReader.BigUInteger
  final public let d: RufoofReader.BigUInteger?
  final public let keySize: Swift.Int
  final public let keySizeBytes: Swift.Int
  public init(n: RufoofReader.BigUInteger, e: RufoofReader.BigUInteger, d: RufoofReader.BigUInteger? = nil)
  convenience public init(n: Swift.Array<Swift.UInt8>, e: Swift.Array<Swift.UInt8>, d: Swift.Array<Swift.UInt8>? = nil)
  convenience public init(keySize: Swift.Int) throws
  public init(n: RufoofReader.BigUInteger, e: RufoofReader.BigUInteger, d: RufoofReader.BigUInteger, p: RufoofReader.BigUInteger, q: RufoofReader.BigUInteger) throws
  @objc deinit
}
extension RufoofReader.RSA {
  convenience public init(rawRepresentation raw: Foundation.Data) throws
}
extension RufoofReader.RSA {
  final public func externalRepresentation() throws -> Foundation.Data
  final public func publicKeyExternalRepresentation() throws -> Foundation.Data
}
extension RufoofReader.CS.BigUInt {
  public static func generatePrime(_ width: Swift.Int) -> RufoofReader.BigUInteger
}
extension RufoofReader.RSA : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
public protocol ImageDownloadRedirectHandler {
  func handleHTTPRedirection(for operation: RufoofReader.ImageDownloadOperation, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct AnyRedirectHandler : RufoofReader.ImageDownloadRedirectHandler {
  public func handleHTTPRedirection(for operation: RufoofReader.ImageDownloadOperation, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public init(handle: @escaping (RufoofReader.ImageDownloadOperation, Foundation.HTTPURLResponse, Foundation.URLRequest, (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
}
extension RufoofReader.CS.BigUInt : Swift.Strideable {
  public typealias Stride = RufoofReader.CS.BigInt
  public func advanced(by n: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigUInt
  public func distance(to other: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigInt
}
extension RufoofReader.CS.BigInt : Swift.Strideable {
  public typealias Stride = RufoofReader.CS.BigInt
  public func advanced(by n: RufoofReader.CS.BigInt.Stride) -> RufoofReader.CS.BigInt
  public func distance(to other: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt.Stride
}
public struct CFB : RufoofReader.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RufoofReader.CFB.Error, b: RufoofReader.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: RufoofReader.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: RufoofReader.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
}
extension RufoofReader.CS.BigUInt {
  public func quotientAndRemainder(dividingBy y: RufoofReader.CS.BigUInt) -> (quotient: RufoofReader.CS.BigUInt, remainder: RufoofReader.CS.BigUInt)
  public static func / (x: RufoofReader.CS.BigUInt, y: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public static func % (x: RufoofReader.CS.BigUInt, y: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public static func /= (x: inout RufoofReader.CS.BigUInt, y: RufoofReader.CS.BigUInt)
  public static func %= (x: inout RufoofReader.CS.BigUInt, y: RufoofReader.CS.BigUInt)
}
extension RufoofReader.CS.BigInt {
  public func quotientAndRemainder(dividingBy y: RufoofReader.CS.BigInt) -> (quotient: RufoofReader.CS.BigInt, remainder: RufoofReader.CS.BigInt)
  public static func / (a: RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func % (a: RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public func modulus(_ mod: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
}
extension RufoofReader.CS.BigInt {
  public static func /= (a: inout RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt)
  public static func %= (a: inout RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt)
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension RufoofReader.Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class TPKeyboardAvoidingTableView : UIKit.UITableView, UIKit.UITextFieldDelegate, UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var contentSize: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func awakeFromNib()
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func willMove(toSuperview newSuperview: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class TPKeyboardAvoidingCollectionView : UIKit.UICollectionView, UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var contentSize: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func awakeFromNib()
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func willMove(toSuperview newSuperview: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class TPKeyboardAvoidingScrollView : UIKit.UIScrollView, UIKit.UITextFieldDelegate, UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var contentSize: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func awakeFromNib()
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func willMove(toSuperview newSuperview: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
}
@_hasMissingDesignatedInitializers public class ImageCoderManager {
  public var coders: [any RufoofReader.ImageCodeable] {
    get
    set
  }
  @objc deinit
}
extension RufoofReader.ImageCoderManager : RufoofReader.ImageCodeable {
  public func canDecode(_ data: Foundation.Data) -> Swift.Bool
  public func decodedImage(with data: Foundation.Data) -> UIKit.UIImage?
  public func decompressedImage(with image: UIKit.UIImage, data: Foundation.Data) -> UIKit.UIImage?
  public func canEncode(_ format: RufoofReader.ImageFormat) -> Swift.Bool
  public func encodedData(with image: UIKit.UIImage, format: RufoofReader.ImageFormat) -> Foundation.Data?
  public func copy() -> any RufoofReader.ImageCodeable
}
extension RufoofReader.ImageCoderManager : RufoofReader.ImageProgressiveCodeable {
  public func canIncrementallyDecode(_ data: Foundation.Data) -> Swift.Bool
  public func incrementallyDecodedImage(with data: Foundation.Data, finished: Swift.Bool) -> UIKit.UIImage?
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class RRReaderView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func setBookId(bookId id: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setBookFileId(bookFileId id: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setTitle(bookTitle title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setBookCover(coverUrl url: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setStartPosition(startPosition position: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setPreviewPercentage(previewPercentage percentage: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func setBookData(bookData data: RufoofReader.RRReaderBookData)
  @_Concurrency.MainActor(unsafe) public func setMarks(allMarks marks: [RufoofReader.NotesAndMarks])
  @_Concurrency.MainActor(unsafe) public func setReaderStyle(readerStyle style: RufoofReader.ReaderStyle)
  @_Concurrency.MainActor(unsafe) public func setSaveState(saveState state: RufoofReader.SaveState)
  @_Concurrency.MainActor(unsafe) public func setDownloadOptionEnabled(optionEnabled enabled: Swift.Bool)
  @objc deinit
}
extension RufoofReader.RRReaderView : RufoofReader.RRBookMakerDelegate {
  @_Concurrency.MainActor(unsafe) public func errorCloseBook()
  @_Concurrency.MainActor(unsafe) public func didCompleteChapter(chapterNo: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func didCompleteAllChapters()
  @_Concurrency.MainActor(unsafe) public func startMotion()
  @_Concurrency.MainActor(unsafe) public func stopMotionUpdates()
  @_Concurrency.MainActor(unsafe) public func didStartLoading()
  @_Concurrency.MainActor(unsafe) public func didUpdateLoading()
}
extension RufoofReader.RRReaderView : UIKit.UICollectionViewDelegate, UIKit.UICollectionViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
}
extension RufoofReader.RRReaderView : RufoofReader.RRAudioPlayerReaderDelegate {
  @_Concurrency.MainActor(unsafe) public func onReSync()
  @_Concurrency.MainActor(unsafe) public func onPairFound(pair: [Swift.Int], chapter: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func onShowPlayLoading()
  @_Concurrency.MainActor(unsafe) public func onStartPlaying()
  @_Concurrency.MainActor(unsafe) public func onPausePlaying()
  @_Concurrency.MainActor(unsafe) public func onGotoPosition(position: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func onGotoChapter(index: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func onGotoAudioPosition(chapter: Swift.Int, position: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func onUpdateRate()
}
extension RufoofReader.RRReaderView {
  @_Concurrency.MainActor(unsafe) public func onDownloadBook()
}
extension RufoofReader.AnimatedCollectionViewLayout {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var flipsHorizontallyInOppositeLayoutDirection: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var developmentLayoutDirection: UIKit.UIUserInterfaceLayoutDirection {
    @objc get
  }
}
extension RufoofReader.RRReaderView : RufoofReader.MarkSliderDelegate {
  @_Concurrency.MainActor(unsafe) public func didSelectMark(chapterIndex: Swift.Int, pageIndex: Swift.Int, pageNo: Swift.Int, markPage: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func didSetValue()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class SpeedBtn : UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public class RRBookInfoModel {
  final public let hasPages: Swift.Bool
  final public let length: Swift.Int
  final public let chapters: Swift.Int
  final public let hasImages: Swift.Bool
  final public let formatVersion: Swift.Int
  final public let language: Swift.String
  public var type: Swift.String
  final public let pages: Swift.Int
  final public let startChapter: Swift.Int
  final public let wordPerPage: Swift.Int
  final public let totalWords: Swift.Int
  final public let readingTime: Swift.Int
  final public let wordsPerMinute: Swift.Int
  final public let isSample: Swift.Bool
  final public let hasAudioSync: Swift.Bool
  final public let audioDuration: Swift.Int
  final public let baseUrl: Swift.String
  public init()
  public init(data: [Swift.String : Any])
  public func isEnglish() -> Swift.Bool
  @objc deinit
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: RufoofReader.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: any RufoofReader.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: any RufoofReader.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: any RufoofReader.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
public struct LinearCardAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public var minAlpha: CoreFoundation.CGFloat
  public var itemSpacing: CoreFoundation.CGFloat
  public var scaleRate: CoreFoundation.CGFloat
  public init(minAlpha: CoreFoundation.CGFloat = 0.5, itemSpacing: CoreFoundation.CGFloat = 0.4, scaleRate: CoreFoundation.CGFloat = 0.7)
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
@usableFromInline
final internal class StreamDecryptor : RufoofReader.Cryptor, RufoofReader.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any RufoofReader.CipherModeWorker
  @usableFromInline
  final internal let padding: RufoofReader.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RufoofReader.Padding, _ worker: any RufoofReader.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
public struct PDFDocument {
  public let pageCount: Swift.Int
  public let fileName: Swift.String
  public init?(url: Foundation.URL, password: Swift.String? = nil)
  public init?(fileData: Foundation.Data, fileName: Swift.String, password: Swift.String? = nil)
}
public func LGPrint(_ object: @autoclosure () -> Any?, _ file: Swift.String = #file, _ function: Swift.String = #function, _ line: Swift.Int = #line)
@_hasMissingDesignatedInitializers public class RRReadingSession {
  public func getBookId() -> Swift.Int
  public func setBookId(_ bookId: Swift.Int)
  public func getBookFileId() -> Swift.Int
  public func setBookFileId(_ bookFileId: Swift.Int) -> RufoofReader.RRReadingSession
  public func getPagesRead() -> Swift.Int
  public func setPagesRead(_ pagesRead: Swift.Int)
  public func getStartOffset() -> Swift.Int
  public func setStartOffset(_ startOffset: Swift.Int)
  public func getEndOffset() -> Swift.Int
  public func setEndOffset(_ endOffset: Swift.Int)
  public func getCoveredOffset() -> [Swift.Int]
  public func setCoveredOffsetArray(_ coveredOffset: [Swift.Int])
  public func setCoveredOffset(_ coveredOffset: [Swift.Int])
  public func getCoveredLength() -> [Swift.Int]
  public func setCoveredLengthArray(_ coveredLength: [Swift.Int])
  public func setCoveredLength(_ coveredLength: [Swift.Int])
  public func getStartTime() -> Swift.Double
  public func setStartTimeMillis(_ startTime: Swift.Double)
  public func getEndTime() -> Swift.Double
  public func setEndTimeMillis(_ endTime: Swift.Double)
  public func getMd5() -> Swift.String
  public func setMd5(_ md5: Swift.String)
  public func getUuid() -> Swift.String?
  public func setUuid(_ uuid: Swift.String?)
  @objc deinit
}
public enum PKCS5 {
}
public struct ZoomInOutAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public var scaleRate: CoreFoundation.CGFloat
  public init(scaleRate: CoreFoundation.CGFloat = 0.2)
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
extension UIKit.UIButton : RufoofReader.ImageWebCacheable {
}
extension RufoofReader.LonginusExtension where Base : UIKit.UIButton {
  public func imageLoadTaskKey(forState state: UIKit.UIControl.State) -> Swift.String
  public func setImage(with resource: (any RufoofReader.ImageWebCacheResourceable)?, forState state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: RufoofReader.LonginusImageOptions? = nil, transformer: RufoofReader.ImageTransformer? = nil, progress: RufoofReader.ImageDownloaderProgressBlock? = nil, completion: RufoofReader.ImageManagerCompletionBlock? = nil)
  public func cancelImageLoadTask(forState state: UIKit.UIControl.State)
  public func setBackgroundImage(with resource: any RufoofReader.ImageWebCacheResourceable, forState state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: RufoofReader.LonginusImageOptions? = nil, transformer: RufoofReader.ImageTransformer? = nil, progress: RufoofReader.ImageDownloaderProgressBlock? = nil, completion: RufoofReader.ImageManagerCompletionBlock? = nil)
  public func cancelBackgroundImageLoadTask(forState state: UIKit.UIControl.State)
  public func backgroundImageLoadTaskKey(forState state: UIKit.UIControl.State) -> Swift.String
}
@_hasMissingDesignatedInitializers final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: RufoofReader.ChaCha20.Error, b: RufoofReader.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  convenience public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension RufoofReader.ChaCha20 : RufoofReader.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension RufoofReader.ChaCha20 {
  public struct ChaChaEncryptor : RufoofReader.Cryptor, RufoofReader.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension RufoofReader.ChaCha20 {
  public struct ChaChaDecryptor : RufoofReader.Cryptor, RufoofReader.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension RufoofReader.ChaCha20 : RufoofReader.Cryptors {
  final public func makeEncryptor() -> any RufoofReader.Cryptor & RufoofReader.Updatable
  final public func makeDecryptor() -> any RufoofReader.Cryptor & RufoofReader.Updatable
}
public struct CrossFadeAttributesAnimator : RufoofReader.LayoutAttributesAnimator {
  public init()
  public func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
public class RRReaderBookData {
  final public let bookInfo: RufoofReader.RRBookInfoModel
  public var toc: [RufoofReader.RRTOCItem]?
  public var audioToc: [RufoofReader.RRTOCItem]?
  public var locations: [Swift.String : Any]?
  public var pages: [Swift.Int]?
  public var syncFile: [[[Swift.Int]]]?
  public init(bookInfo info: RufoofReader.RRBookInfoModel, bookToc toc: [RufoofReader.RRTOCItem], audioToc aToc: [RufoofReader.RRTOCItem]?, bookLocations locations: [Swift.String : Any]?, bookPages pages: [Swift.Int]?, bookSyncFile syncFile: [[[Swift.Int]]])
  public init(bookInfo: RufoofReader.RRBookInfoModel, bookToc toc: [RufoofReader.RRTOCItem])
  public init()
  @objc deinit
}
extension RufoofReader.AES : RufoofReader.Cryptors {
  @inlinable final public func makeEncryptor() throws -> any RufoofReader.Cryptor & RufoofReader.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> any RufoofReader.Cryptor & RufoofReader.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
public protocol ImageDownloadModifier {
  associatedtype T
  func modified(for original: Self.T?) -> Self.T?
}
public struct URLRequestModifier : RufoofReader.ImageDownloadModifier {
  public func modified(for request: Foundation.URLRequest?) -> Foundation.URLRequest?
  public init(modify: @escaping (Foundation.URLRequest?) -> Foundation.URLRequest?)
  public typealias T = Foundation.URLRequest
}
public struct URLModifier : RufoofReader.ImageDownloadModifier {
  public func modified(for URL: Foundation.URL?) -> Foundation.URL?
  public init(url: Foundation.URL?)
  public typealias T = Foundation.URL
}
public struct URLHttpHeadersModifier : RufoofReader.ImageDownloadModifier {
  public func modified(for headers: [Swift.String : Swift.String]?) -> [Swift.String : Swift.String]?
  public init(httpHeaders: [Swift.String : Swift.String]?)
  public typealias T = [Swift.String : Swift.String]
}
final public class XChaCha20 : RufoofReader.BlockMode {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: RufoofReader.XChaCha20.Error, b: RufoofReader.XChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>, blockCounter: Swift.UInt32 = 0) throws
  final public let options: RufoofReader.BlockModeOption
  final public let customBlockSize: Swift.Int?
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
  @objc deinit
}
extension RufoofReader.XChaCha20 : RufoofReader.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension RufoofReader.XChaCha20 : RufoofReader.Cryptors {
  final public func makeEncryptor() throws -> any RufoofReader.Cryptor & RufoofReader.Updatable
  final public func makeDecryptor() throws -> any RufoofReader.Cryptor & RufoofReader.Updatable
}
public class Queuer {
  public static let shared: RufoofReader.Queuer
  final public let queue: Foundation.OperationQueue
  public var operationCount: Swift.Int {
    get
  }
  public var operations: [Foundation.Operation] {
    get
  }
  public var qualityOfService: Foundation.QualityOfService {
    get
    set
  }
  public var isExecuting: Swift.Bool {
    get
  }
  public var maxConcurrentOperationCount: Swift.Int {
    get
    set
  }
  public init(name: Swift.String, maxConcurrentOperationCount: Swift.Int = Int.max, qualityOfService: Foundation.QualityOfService = .default)
  public func cancelAll()
  public func pause()
  public func resume()
  public func waitUntilAllOperationsAreFinished()
  @objc deinit
}
extension RufoofReader.Queuer {
  public func addOperation(_ operation: @escaping () -> Swift.Void)
  public func addOperation(_ operation: Foundation.Operation)
  public func addChainedOperations(_ operations: [Foundation.Operation], completionHandler: (() -> Swift.Void)? = nil)
  public func addChainedOperations(_ operations: Foundation.Operation..., completionHandler: (() -> Swift.Void)? = nil)
  public func addCompletionHandler(_ completionHandler: @escaping () -> Swift.Void)
}
extension RufoofReader.Queuer {
  public typealias QueueStateList = [RufoofReader.OperationState]
  public func state() -> RufoofReader.Queuer.QueueStateList
  public static func state(of queue: Foundation.OperationQueue) -> RufoofReader.Queuer.QueueStateList
}
extension UIKit.UIApplication : RufoofReader.LonginusCompatible {
}
extension RufoofReader.LonginusExtension where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
public enum CompressionMethod : Swift.UInt16 {
  case none
  case deflate
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public typealias CRC32 = Swift.UInt32
public typealias Consumer = (_ data: Foundation.Data) throws -> Swift.Void
public typealias Provider = (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data
extension Foundation.Data {
  public func crc32(checksum: RufoofReader.CRC32) -> RufoofReader.CRC32
  public static func compress(size: Swift.Int64, bufferSize: Swift.Int, provider: (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> RufoofReader.CRC32
  public static func decompress(size: Swift.Int64, bufferSize: Swift.Int, skipCRC32: Swift.Bool, provider: (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> RufoofReader.CRC32
}
public class Mutex {
  public init()
  @discardableResult
  final public func lock() -> Swift.Int32
  @discardableResult
  final public func trylock() -> Swift.Int32
  @discardableResult
  final public func unlock() -> Swift.Int32
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class RRDimmedView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
final public class HMAC : RufoofReader.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: RufoofReader.HMAC.Error, b: RufoofReader.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case md5
    case sha1
    case sha2(RufoofReader.SHA2.Variant)
    case sha3(RufoofReader.SHA3.Variant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256, sha384, sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: RufoofReader.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension RufoofReader.Archive {
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: RufoofReader.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, fileURL: Foundation.URL, compressionMethod: RufoofReader.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, type: RufoofReader.Entry.EntryType, uncompressedSize: Swift.Int64, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: RufoofReader.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data) throws
  final public func remove(_ entry: RufoofReader.Entry, bufferSize: Swift.Int = defaultReadChunkSize, progress: Foundation.Progress? = nil) throws
}
public protocol ImageDownloadOperateable : AnyObject {
  var url: Foundation.URL { get }
  var dataTaskId: Swift.Int { get }
  var downloads: [RufoofReader.ImageDefaultDownload] { get }
  var imageCoder: (any RufoofReader.ImageCodeable)? { get set }
  var completion: (() -> Swift.Void)? { get set }
  init(request: Foundation.URLRequest, session: Foundation.URLSession, options: RufoofReader.LonginusImageOptions?)
  func add(download: RufoofReader.ImageDefaultDownload)
  func start()
  func cancel()
}
@objc public class ImageDownloadOperation : ObjectiveC.NSObject, RufoofReader.ImageDownloadOperateable {
  public var url: Foundation.URL {
    get
  }
  public var dataTaskId: Swift.Int {
    get
  }
  public var downloads: [RufoofReader.ImageDefaultDownload] {
    get
  }
  public var options: RufoofReader.LonginusImageOptions?
  weak public var imageCoder: (any RufoofReader.ImageCodeable)?
  public var completion: (() -> Swift.Void)?
  required public init(request: Foundation.URLRequest, session: Foundation.URLSession, options: RufoofReader.LonginusImageOptions?)
  public func add(download: RufoofReader.ImageDefaultDownload)
  public func start()
  public func cancel()
  @objc deinit
}
extension RufoofReader.ImageDownloadOperation : Foundation.URLSessionTaskDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
}
extension RufoofReader.ImageDownloadOperation : Foundation.URLSessionDataDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
}
public struct RRPanModalAnimator {
}
extension RufoofReader.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class SHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension RufoofReader.SHA1 : RufoofReader.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: RufoofReader.SHA3.Variant, b: RufoofReader.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: RufoofReader.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension RufoofReader.SHA3 : RufoofReader.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  final public func callAsFunction() throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension RufoofReader.Archive {
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: RufoofReader.CompressionMethod = .none, bufferSize: Swift.UInt32, progress: Foundation.Progress? = nil) throws
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func addEntry(with path: Swift.String, fileURL: Foundation.URL, compressionMethod: RufoofReader.CompressionMethod = .none, bufferSize: Swift.UInt32, progress: Foundation.Progress? = nil) throws
  @available(*, deprecated, message: "Please use `Int64` for `uncompressedSize` and provider `position`. `Int` for `bufferSize`.")
  final public func addEntry(with path: Swift.String, type: RufoofReader.Entry.EntryType, uncompressedSize: Swift.UInt32, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: RufoofReader.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data) throws
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func remove(_ entry: RufoofReader.Entry, bufferSize: Swift.UInt32, progress: Foundation.Progress? = nil) throws
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedCollectionViewLayout : UIKit.UICollectionViewFlowLayout {
  @_Concurrency.MainActor(unsafe) open var animator: (any RufoofReader.LayoutAttributesAnimator)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open class var layoutAttributesClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutAttributesForElements(in rect: CoreFoundation.CGRect) -> [UIKit.UICollectionViewLayoutAttributes]?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func shouldInvalidateLayout(forBoundsChange newBounds: CoreFoundation.CGRect) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedCollectionViewLayoutAttributes : UIKit.UICollectionViewLayoutAttributes {
  @_Concurrency.MainActor(unsafe) public var contentView: UIKit.UIView?
  @_Concurrency.MainActor(unsafe) public var scrollDirection: UIKit.UICollectionView.ScrollDirection
  @_Concurrency.MainActor(unsafe) public var startOffset: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var middleOffset: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var endOffset: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
}
public struct OFB : RufoofReader.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RufoofReader.OFB.Error, b: RufoofReader.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: RufoofReader.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
}
@objc public class RRPanModalPresentationAnimator : ObjectiveC.NSObject {
  public enum TransitionStyle {
    case presentation
    case dismissal
    public static func == (a: RufoofReader.RRPanModalPresentationAnimator.TransitionStyle, b: RufoofReader.RRPanModalPresentationAnimator.TransitionStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  required public init(transitionStyle: RufoofReader.RRPanModalPresentationAnimator.TransitionStyle)
  @objc deinit
}
extension RufoofReader.RRPanModalPresentationAnimator : UIKit.UIViewControllerAnimatedTransitioning {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func transitionDuration(using transitionContext: (any UIKit.UIViewControllerContextTransitioning)?) -> Foundation.TimeInterval
  @_Concurrency.MainActor(unsafe) @objc dynamic public func animateTransition(using transitionContext: any UIKit.UIViewControllerContextTransitioning)
}
public var currentBookLanguage: Swift.String
public var rrReaderView: RufoofReader.RRReaderView?
public var rrAudioPlayer: RufoofReader.RRAudioPlayer?
public var rrMiniAudioPlayer: RufoofReader.RRMiniAudioPlayer?
public var bookReaderTopConstraint: UIKit.NSLayoutConstraint!
public var audioPlayerTopConstraint: UIKit.NSLayoutConstraint!
public var miniAudioPlayerBottomMargin: CoreFoundation.CGFloat
public var rrWindow: UIKit.UIWindow?
public class ReaderBuilder {
  public init(bookId: Swift.Int, language: RufoofReader.Language)
  public func build()
  public func setReaderDelegate(withReaderDelegate readerDelegate: (any RufoofReader.ReaderDelegate)?)
  public func setReadingStatsDelegate(withStatsSessionDelegate statsSessionDelegate: (any RufoofReader.StatsSessionDelegate)?)
  public func setReaderStyle(readerStyle style: RufoofReader.ReaderStyle)
  public func setFileId(fileId id: Swift.Int)
  public func setTitle(bookTitle title: Swift.String)
  public func setCover(coverURL url: Swift.String)
  public func setPosition(startPosition position: Swift.Int)
  public func setPercentageView(previewPercentage percentage: Swift.Double)
  public func setSaveState(saveState state: RufoofReader.SaveState)
  public func setDownloadEnabled(downloadEnabled enabled: Swift.Bool)
  public func setMiniPlayerMargin(miniPlayerMargin margin: CoreFoundation.CGFloat)
  public func setMarks(allMarks marks: [RufoofReader.NotesAndMarks])
  public func setCurrentJumpTime(jumpTime time: Swift.Int)
  public func setCurrentRate(rateIndex index: Swift.Int)
  public func setAudioStartChapter(audioStartChapter index: Swift.Int)
  public func closeBook()
  public func onStartDownloadLoading()
  public func onStopDownloadLoading()
  public func onUpdateDownloadProgress(bookId: Swift.Int, progress: Swift.Float)
  public func onHideDownloadProgress()
  public func onReaderClosed(position: Swift.Int)
  public func onPositionChanged(position: Swift.Int)
  public func onSyncNotesAndMarks(list: [RufoofReader.NotesAndMarks])
  public func onSaveBookClicked(position: Swift.Int)
  public func onEndOfSample()
  @objc deinit
}
extension RufoofReader.ReaderBuilder : RufoofReader.RRReaderViewDelegate {
  public func onSyncReadingSession(session: RufoofReader.RRReadingSession)
  public func onStyleChanged(style: RufoofReader.ReaderStyle)
  public func onBookDetailsCLicked()
  public func onShareBook()
  public func onDownloadBook()
}
extension RufoofReader.ReaderBuilder : RufoofReader.RRAudioPlayerDelegate {
}
extension RufoofReader.ReaderBuilder : RufoofReader.RRPDFViewDelegate {
}
@objc @_hasMissingDesignatedInitializers public class ImageLoadTask : ObjectiveC.NSObject {
  public var isCancelled: Swift.Bool {
    get
  }
  final public let url: Foundation.URL
  final public let sentinel: Swift.Int32
  public var download: RufoofReader.ImageDefaultDownload?
  weak public var imageManager: RufoofReader.LonginusManager?
  public func cancel()
  public static func == (lhs: RufoofReader.ImageLoadTask, rhs: RufoofReader.ImageLoadTask) -> Swift.Bool
  @objc override dynamic public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
public enum Gzip {
  public static let maxWindowBits: Swift.Int32
}
public struct CompressionLevel : Swift.RawRepresentable, Swift.Sendable {
  public let rawValue: Swift.Int32
  public static let noCompression: RufoofReader.CompressionLevel
  public static let bestSpeed: RufoofReader.CompressionLevel
  public static let bestCompression: RufoofReader.CompressionLevel
  public static let defaultCompression: RufoofReader.CompressionLevel
  public init(rawValue: Swift.Int32)
  public init(_ rawValue: Swift.Int32)
  public typealias RawValue = Swift.Int32
}
public struct GzipError : Swift.Error, Swift.Sendable {
  public enum Kind : Swift.Equatable, Swift.Sendable {
    case stream
    case data
    case memory
    case buffer
    case version
    case unknown(code: Swift.Int)
    public static func == (a: RufoofReader.GzipError.Kind, b: RufoofReader.GzipError.Kind) -> Swift.Bool
  }
  public let kind: RufoofReader.GzipError.Kind
  public let message: Swift.String
  public var localizedDescription: Swift.String {
    get
  }
}
extension Foundation.Data {
  public var isGzipped: Swift.Bool {
    get
  }
  public func gzipped(level: RufoofReader.CompressionLevel = .defaultCompression, wBits: Swift.Int32 = Gzip.maxWindowBits + 16) throws -> Foundation.Data
  public func gunzipped(wBits: Swift.Int32 = Gzip.maxWindowBits + 32) throws -> Foundation.Data
  public func gtm_dataByInflatingBytes(_ bytes: Swift.UnsafeRawPointer?, length: Swift.UInt) -> Foundation.Data?
}
public protocol RRPDFViewDelegate {
  func onSaveBookClicked(position: Swift.Int)
  func onSyncNotesAndMarks(list: [RufoofReader.NotesAndMarks])
  func onReaderClosed(position: Swift.Int)
  func onPositionChanged(position: Swift.Int)
}
final public class Poly1305 : RufoofReader.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: RufoofReader.Poly1305.Error, b: RufoofReader.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public protocol RRPanModalPresentable : AnyObject {
  var panScrollable: UIKit.UIScrollView? { get }
  var topOffset: CoreFoundation.CGFloat { get }
  var shortFormHeight: RufoofReader.RRPanModalHeight { get }
  var longFormHeight: RufoofReader.RRPanModalHeight { get }
  var cornerRadius: CoreFoundation.CGFloat { get }
  var springDamping: CoreFoundation.CGFloat { get }
  var transitionDuration: Swift.Double { get }
  var transitionAnimationOptions: UIKit.UIView.AnimationOptions { get }
  var panModalBackgroundColor: UIKit.UIColor { get }
  var dragIndicatorBackgroundColor: UIKit.UIColor { get }
  var scrollIndicatorInsets: UIKit.UIEdgeInsets { get }
  var anchorModalToLongForm: Swift.Bool { get }
  var allowsExtendedPanScrolling: Swift.Bool { get }
  var allowsDragToDismiss: Swift.Bool { get }
  var allowsTapToDismiss: Swift.Bool { get }
  var isUserInteractionEnabled: Swift.Bool { get }
  var isHapticFeedbackEnabled: Swift.Bool { get }
  var shouldRoundTopCorners: Swift.Bool { get }
  var showDragIndicator: Swift.Bool { get }
  func shouldRespond(to panModalGestureRecognizer: UIKit.UIPanGestureRecognizer) -> Swift.Bool
  func willRespond(to panModalGestureRecognizer: UIKit.UIPanGestureRecognizer)
  func shouldPrioritize(panModalGestureRecognizer: UIKit.UIPanGestureRecognizer) -> Swift.Bool
  func shouldTransition(to state: RufoofReader.RRPanModalPresentationController.PresentationState) -> Swift.Bool
  func willTransition(to state: RufoofReader.RRPanModalPresentationController.PresentationState)
  func panModalWillDismiss()
  func panModalDidDismiss()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class PDFViewController : UIKit.UIViewController {
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) final public var collectionView: UIKit.UICollectionView!
  @_Concurrency.MainActor(unsafe) final public var backgroundColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var scrollDirection: UIKit.UICollectionView.ScrollDirection {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var resetZoom: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var preferredStatusBarUpdateAnimation: UIKit.UIStatusBarAnimation {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func shouldPerformSegue(withIdentifier identifier: Swift.String, sender: Any?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func prepare(for segue: UIKit.UIStoryboardSegue, sender: Any?)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension RufoofReader.PDFViewController : UIKit.UICollectionViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc final public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc final public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
}
extension RufoofReader.PDFViewController : UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor(unsafe) @objc final public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
}
extension RufoofReader.PDFViewController : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
}
public protocol RRBookMakerDelegate {
  func didCompleteChapter(chapterNo: Swift.Int)
  func didCompleteAllChapters()
  func didStartLoading()
  func didUpdateLoading()
  func errorCloseBook()
}
public class RRBookMaker {
  public init(bookId: Swift.Int, bookInfoModel model: RufoofReader.RRBookInfoModel, startingChapter index: Swift.Int, withDelegate delegate: (any RufoofReader.RRBookMakerDelegate)?)
  public var rrchapterBuilder: RufoofReader.RRChapterBuilder!
  public func getCollectionViewChapters() -> [RufoofReader.RRChapterItem]
  public func getNoOfPages() -> Swift.Int
  @objc deinit
}
public class RRTOCItem {
  public init(data: [Swift.String : Any])
  public init(title: Swift.String, offset: Swift.Int, pages: Swift.Int, wordCount: Swift.Int, readingTime: Swift.Int, length: Swift.Int, audioUrl: Swift.String, audioFile: Swift.String, audioOffset: Swift.Double, audioLength: Swift.Int, hasAudioSync: Swift.Bool, cropping: Swift.String)
  @objc deinit
}
extension RufoofReader.CS.BigUInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension RufoofReader.CS.BigInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension Swift.String {
  public init(_ v: RufoofReader.CS.BigUInt)
  public init(_ v: RufoofReader.CS.BigUInt, radix: Swift.Int, uppercase: Swift.Bool = false)
  public init(_ value: RufoofReader.CS.BigInt, radix: Swift.Int = 10, uppercase: Swift.Bool = false)
}
extension RufoofReader.CS.BigUInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension RufoofReader.CS.BigInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension RufoofReader.CS.BigUInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RufoofReader.CS.BigInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RufoofReader.CS.BigUInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension RufoofReader.CS.BigInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
public protocol RRAudioPlayerDelegate {
  func onSyncNotesAndMarks(list: [RufoofReader.NotesAndMarks])
  func onReaderClosed(position: Swift.Int)
  func onPositionChanged(position: Swift.Int)
  func onSaveBookClicked(position: Swift.Int)
  func onEndOfSample()
}
public protocol AuthenticationChallengeResponsable : AnyObject {
  func downloader(_ downloader: RufoofReader.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  func downloader(_ downloader: RufoofReader.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension RufoofReader.AuthenticationChallengeResponsable {
  public func downloader(_ downloader: RufoofReader.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  public func downloader(_ downloader: RufoofReader.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public enum AnimatedImageViewType {
  case none
  case image
  case hilightedImage
  case animationImages
  case hilightedAnimationImages
  public static func == (a: RufoofReader.AnimatedImageViewType, b: RufoofReader.AnimatedImageViewType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedImageView : UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) public var isAutoPlayAnimatedImage: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var currentAnimatedImageIndex: Swift.Int {
    get
  }
  @_Concurrency.MainActor(unsafe) public var runLoopMode: Foundation.RunLoop.Mode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var currentIsPlayingAnimation: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isAnimating: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var image: UIKit.UIImage? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var highlightedImage: UIKit.UIImage? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var animationImages: [UIKit.UIImage]? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var highlightedAnimationImages: [UIKit.UIImage]? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func encode(with aCoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func stopAnimating()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func startAnimating()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func display(_ layer: QuartzCore.CALayer)
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func currentImageType() -> RufoofReader.AnimatedImageViewType
  @_Concurrency.MainActor(unsafe) public func setCurrentAnimatedImageIndex(_ index: Swift.Int)
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor(unsafe) public static var key: UIKit.UIWindow? {
    get
  }
}
extension RufoofReader.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: RufoofReader.Padding = .pkcs7) throws
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64(options: Foundation.Data.Base64EncodingOptions = []) -> Swift.String
  public init(base64: Swift.String, options: Foundation.Data.Base64DecodingOptions = .ignoreUnknownCharacters)
}
public class RufoofManager {
  public init()
  public func createFoldersAndDb()
  @objc deinit
}
public let LonginusImageErrorDomain: Swift.String
public typealias ImageDownloaderProgressBlock = (Foundation.Data?, _ expectedSize: Swift.Int, UIKit.UIImage?) -> Swift.Void
public typealias ImageDownloaderCompletionBlock = (Foundation.Data?, (any Swift.Error)?) -> Swift.Void
public typealias ImageManagerCompletionBlock = (UIKit.UIImage?, Foundation.Data?, (any Swift.Error)?, RufoofReader.ImageCacheType) -> Swift.Void
public typealias ImagePreloadProgress = (_ successCount: Swift.Int, _ finishCount: Swift.Int, _ total: Swift.Int) -> Swift.Void
public typealias ImagePreloadCompletion = (_ successCount: Swift.Int, _ total: Swift.Int) -> Swift.Void
public protocol ImageDownloadable : AnyObject {
  func downloadImage(with url: Foundation.URL, options: RufoofReader.LonginusImageOptions?, progress: RufoofReader.ImageDownloaderProgressBlock?, completion: @escaping RufoofReader.ImageDownloaderCompletionBlock) -> RufoofReader.ImageDefaultDownload
  func cancel(download: RufoofReader.ImageDefaultDownload)
  func cancel(url: Foundation.URL)
  func cancelPreloading()
  func cancelAll()
}
@_hasMissingDesignatedInitializers public class ImageDefaultDownload {
  @objc deinit
}
public class ImageDownloader {
  public var donwloadTimeout: Foundation.TimeInterval
  public var requestsUsePipelining: Swift.Bool
  weak public var imageCoder: (any RufoofReader.ImageCodeable)?
  public var generateDownload: (Foundation.URL, RufoofReader.ImageDownloaderProgressBlock?, @escaping RufoofReader.ImageDownloaderCompletionBlock) -> RufoofReader.ImageDefaultDownload {
    get
    set
  }
  public var generateDownloadOperation: (Foundation.URLRequest, Foundation.URLSession, RufoofReader.LonginusImageOptions?) -> any RufoofReader.ImageDownloadOperateable {
    get
    set
  }
  public var currentDownloadCount: Swift.Int {
    get
  }
  public var currentPreloadTaskCount: Swift.Int {
    get
  }
  public var maxConcurrentDownloadCount: Swift.Int {
    get
    set
  }
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var trustedHosts: Swift.Set<Swift.String>?
  weak open var authenticationChallengeResponder: (any RufoofReader.AuthenticationChallengeResponsable)?
  public init(sessionConfiguration: Foundation.URLSessionConfiguration)
  @objc deinit
}
extension RufoofReader.ImageDownloader : RufoofReader.ImageDownloadable {
  @discardableResult
  public func downloadImage(with url: Foundation.URL, options: RufoofReader.LonginusImageOptions? = nil, progress: RufoofReader.ImageDownloaderProgressBlock? = nil, completion: @escaping RufoofReader.ImageDownloaderCompletionBlock) -> RufoofReader.ImageDefaultDownload
  public func cancel(download: RufoofReader.ImageDefaultDownload)
  public func cancel(url: Foundation.URL)
  public func cancelPreloading()
  public func cancelAll()
}
extension RufoofReader.ImageDownloader : RufoofReader.AuthenticationChallengeResponsable {
}
extension Foundation.FileManager {
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool = true, compressionMethod: RufoofReader.CompressionMethod = .none, progress: Foundation.Progress? = nil) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, preferredEncoding: Swift.String.Encoding? = nil) throws
}
extension Foundation.URL {
  public func isContained(in parentDirectoryURL: Foundation.URL) -> Swift.Bool
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits  448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
public struct CBC : RufoofReader.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RufoofReader.CBC.Error, b: RufoofReader.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: RufoofReader.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
}
extension QuartzCore.CALayer : RufoofReader.ImageWebCacheable {
}
extension RufoofReader.LonginusExtension where Base : QuartzCore.CALayer {
  public var imageLoadTaskKey: Swift.String {
    get
  }
  public func setImage(with resource: (any RufoofReader.ImageWebCacheResourceable)?, placeholder: UIKit.UIImage? = nil, options: RufoofReader.LonginusImageOptions? = nil, transformer: RufoofReader.ImageTransformer? = nil, progress: RufoofReader.ImageDownloaderProgressBlock? = nil, completion: RufoofReader.ImageManagerCompletionBlock? = nil)
  public func cancelImageLoadTask()
}
extension RufoofReader.RRPanModalPresentable where Self : UIKit.UIViewController {
  public typealias AnimationBlockType = () -> Swift.Void
  public typealias AnimationCompletionType = (Swift.Bool) -> Swift.Void
  public typealias LayoutType = UIKit.UIViewController & RufoofReader.RRPanModalPresentable
  public func panModalTransition(to state: RufoofReader.RRPanModalPresentationController.PresentationState)
  public func panModalSetNeedsLayoutUpdate()
  public func panModalPerformUpdates(_ updates: () -> Swift.Void)
  public func panModalAnimate(_ animationBlock: @escaping Self.AnimationBlockType, _ completion: Self.AnimationCompletionType? = nil)
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: RufoofReader.CCM.Error, b: RufoofReader.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: RufoofReader.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RufoofReader.CipherOperationOnBlock, encryptionOperation: @escaping RufoofReader.CipherOperationOnBlock) throws -> any RufoofReader.CipherModeWorker
}
public let defaultReadChunkSize: Swift.Int
public let defaultWriteChunkSize: Swift.Int
public let defaultFilePermissions: Swift.UInt16
public let defaultDirectoryPermissions: Swift.UInt16
final public class Archive : Swift.Sequence {
  public enum ArchiveError : Swift.Error {
    case unreadableArchive
    case unwritableArchive
    case invalidEntryPath
    case invalidCompressionMethod
    case invalidCRC32
    case cancelledOperation
    case invalidBufferSize
    case invalidEntrySize
    case invalidLocalHeaderDataOffset
    case invalidLocalHeaderSize
    case invalidCentralDirectoryOffset
    case invalidCentralDirectorySize
    case invalidCentralDirectoryEntryCount
    case missingEndOfCentralDirectoryRecord
    public static func == (a: RufoofReader.Archive.ArchiveError, b: RufoofReader.Archive.ArchiveError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AccessMode : Swift.UInt {
    case create
    case read
    case update
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  final public let url: Foundation.URL
  final public let accessMode: RufoofReader.Archive.AccessMode
  public init?(url: Foundation.URL, accessMode mode: RufoofReader.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  public init?(data: Foundation.Data = Data(), accessMode mode: RufoofReader.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  @objc deinit
  final public func makeIterator() -> Swift.AnyIterator<RufoofReader.Entry>
  final public subscript(path: Swift.String) -> RufoofReader.Entry? {
    get
  }
  public typealias Element = RufoofReader.Entry
  public typealias Iterator = Swift.AnyIterator<RufoofReader.Entry>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class RRAudioPlayer : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func setCurrentRate(rateIndex index: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setBookId(bookId id: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setBookFileId(bookFileId id: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setTitle(bookTitle title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setAuthor(bookAuthor author: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setBookCover(coverUrl url: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setStartPosition(startPosition position: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setPreviewPercentage(previewPercentage percentage: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func setBookData(bookData data: RufoofReader.RRReaderBookData)
  @_Concurrency.MainActor(unsafe) public func setMarks(allMarks marks: [RufoofReader.NotesAndMarks])
  @_Concurrency.MainActor(unsafe) public func setSaveState(saveState state: RufoofReader.SaveState)
  @_Concurrency.MainActor(unsafe) public func setDownloadOptionEnabled(optionEnabled enabled: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func setCurrentSkipTime(skipTime time: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setAudioStartChapter(audioStartChapter index: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setStartFromSeconds(startFromSeconds seconds: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func fixSettingsView()
  @_Concurrency.MainActor(unsafe) public func startDownloadLoading()
  @_Concurrency.MainActor(unsafe) public func stopDownloadLoading()
  @_Concurrency.MainActor(unsafe) public func updateDownloadProgress(bookId: Swift.Int, progress: Swift.Float)
  @_Concurrency.MainActor(unsafe) public func hideDownloadProgress()
  @objc deinit
}
extension RufoofReader.RRAudioPlayer : RufoofReader.JukeboxDelegate {
  @_Concurrency.MainActor(unsafe) public func jukeboxStateDidChange(_ state: RufoofReader.Jukebox)
  @_Concurrency.MainActor(unsafe) public func jukeboxPlaybackProgressDidChange(_ jukebox: RufoofReader.Jukebox)
  @_Concurrency.MainActor(unsafe) public func jukeboxDidLoadItem(_ jukebox: RufoofReader.Jukebox, item: RufoofReader.JukeboxItem)
  @_Concurrency.MainActor(unsafe) public func jukeboxDidUpdateMetadata(_ jukebox: RufoofReader.Jukebox, forItem: RufoofReader.JukeboxItem)
  @_Concurrency.MainActor(unsafe) public func jukeboxDidPlayToEnd()
}
@_hasMissingDesignatedInitializers public class RRBookDataModel {
  @objc deinit
}
public class Histogram {
  public init(fiveStars: Swift.Int? = nil, fourStars: Swift.Int? = nil, threeStars: Swift.Int? = nil, twoStars: Swift.Int? = nil, oneStar: Swift.Int? = nil, total: Swift.Int? = nil)
  @objc deinit
}
public class SubscriptionsAvailable {
  public init(subscription_id: Swift.Int? = nil, subscription_name: Swift.String? = nil, expiry_date: Swift.Int? = nil)
  @objc deinit
}
public class SeriesModel {
  public init(data: [Swift.String : Any])
  @objc deinit
}
public class AuthorDataModel {
  public init(data: [Swift.String : Any])
  public init(cmsData: [Swift.String : Any])
  @objc deinit
}
extension RufoofReader.RRPanModalPresentable where Self : UIKit.UIViewController {
  public var topOffset: CoreFoundation.CGFloat {
    get
  }
  public var shortFormHeight: RufoofReader.RRPanModalHeight {
    get
  }
  public var longFormHeight: RufoofReader.RRPanModalHeight {
    get
  }
  public var cornerRadius: CoreFoundation.CGFloat {
    get
  }
  public var springDamping: CoreFoundation.CGFloat {
    get
  }
  public var transitionDuration: Swift.Double {
    get
  }
  public var transitionAnimationOptions: UIKit.UIView.AnimationOptions {
    get
  }
  public var panModalBackgroundColor: UIKit.UIColor {
    get
  }
  public var dragIndicatorBackgroundColor: UIKit.UIColor {
    get
  }
  public var scrollIndicatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var anchorModalToLongForm: Swift.Bool {
    get
  }
  public var allowsExtendedPanScrolling: Swift.Bool {
    get
  }
  public var allowsDragToDismiss: Swift.Bool {
    get
  }
  public var allowsTapToDismiss: Swift.Bool {
    get
  }
  public var isUserInteractionEnabled: Swift.Bool {
    get
  }
  public var isHapticFeedbackEnabled: Swift.Bool {
    get
  }
  public var shouldRoundTopCorners: Swift.Bool {
    get
  }
  public var showDragIndicator: Swift.Bool {
    get
  }
  public func shouldRespond(to panModalGestureRecognizer: UIKit.UIPanGestureRecognizer) -> Swift.Bool
  public func willRespond(to panModalGestureRecognizer: UIKit.UIPanGestureRecognizer)
  public func shouldTransition(to state: RufoofReader.RRPanModalPresentationController.PresentationState) -> Swift.Bool
  public func shouldPrioritize(panModalGestureRecognizer: UIKit.UIPanGestureRecognizer) -> Swift.Bool
  public func willTransition(to state: RufoofReader.RRPanModalPresentationController.PresentationState)
  public func panModalWillDismiss()
  public func panModalDidDismiss()
}
public struct Scheduler {
  public var timer: any Dispatch.DispatchSourceTimer {
    get
  }
  public var deadline: Dispatch.DispatchTime {
    get
  }
  public var repeating: Dispatch.DispatchTimeInterval {
    get
  }
  public var qualityOfService: Dispatch.DispatchQoS {
    get
  }
  public var handler: (() -> Swift.Void)? {
    get
  }
  public init(deadline: Dispatch.DispatchTime, repeating: Dispatch.DispatchTimeInterval, qualityOfService: Dispatch.DispatchQoS = .default, handler: (() -> Swift.Void)? = nil)
  public mutating func setHandler(_ handler: @escaping () -> Swift.Void)
}
extension RufoofReader.Archive {
  final public func extract(_ entry: RufoofReader.Entry, to url: Foundation.URL, bufferSize: Swift.Int = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil) throws -> RufoofReader.CRC32
  final public func extract(_ entry: RufoofReader.Entry, bufferSize: Swift.Int = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> RufoofReader.CRC32
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: RufoofReader.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: RufoofReader.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: RufoofReader.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: RufoofReader.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension RufoofReader.SHA2 : RufoofReader.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
public typealias LonginusImageOptions = [RufoofReader.LonginusImageOptionItem]
public enum LonginusImageOptionItem {
  case queryDataWhenInMemory
  case ignoreDiskCache
  case refreshCache
  case retryFailedUrl
  case useURLCache
  case handleCookies
  case requestModifier(RufoofReader.URLRequestModifier)
  case httpHeadersModifier(RufoofReader.URLHttpHeadersModifier)
  case redirectHandler(any RufoofReader.ImageDownloadRedirectHandler)
  case progressiveDownload
  case progressiveBlur
  case ignorePlaceholder
  case ignoreImageDecoding
  case imageWithFadeAnimation
  case showNetworkActivity
  case ignoreAnimatedImage
  case preload
}
public struct LonginusParsedImageOptionsInfo {
  public var queryDataWhenInMemory: Swift.Bool
  public var ignoreDiskCache: Swift.Bool
  public var refreshCache: Swift.Bool
  public var retryFailedUrl: Swift.Bool
  public var useURLCache: Swift.Bool
  public var handleCookies: Swift.Bool
  public var progressiveDownload: Swift.Bool
  public var ignorePlaceholder: Swift.Bool
  public var ignoreImageDecoding: Swift.Bool
  public var imageWithFadeAnimation: Swift.Bool
  public var showNetworkActivity: Swift.Bool
  public var progressiveBlur: Swift.Bool
  public var ignoreAnimatedImage: Swift.Bool
  public var requestModifier: RufoofReader.URLRequestModifier?
  public var httpHeadersModifier: RufoofReader.URLHttpHeadersModifier?
  public var redirectHandler: (any RufoofReader.ImageDownloadRedirectHandler)?
  public init(_ options: RufoofReader.LonginusImageOptions?)
}
@usableFromInline
final internal class BlockEncryptor : RufoofReader.Cryptor, RufoofReader.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RufoofReader.Padding, _ worker: any RufoofReader.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension UIKit.UIImageView : RufoofReader.ImageWebCacheable {
}
extension RufoofReader.LonginusExtension where Base : UIKit.UIImageView {
  public func setImage(with resource: (any RufoofReader.ImageWebCacheResourceable)?, placeholder: UIKit.UIImage? = nil, options: RufoofReader.LonginusImageOptions? = nil, transformer: RufoofReader.ImageTransformer? = nil, progress: RufoofReader.ImageDownloaderProgressBlock? = nil, completion: RufoofReader.ImageManagerCompletionBlock? = nil)
  public func setHighlightedImage(with resource: any RufoofReader.ImageWebCacheResourceable, placeholder: UIKit.UIImage? = nil, options: RufoofReader.LonginusImageOptions? = nil, transformer: RufoofReader.ImageTransformer? = nil, progress: RufoofReader.ImageDownloaderProgressBlock? = nil, completion: RufoofReader.ImageManagerCompletionBlock? = nil)
  public func cancelHighlightedImageLoadTask()
  public var highlightedImageLoadTaskKey: Swift.String {
    get
  }
  public func cancelImageLoadTask()
  public var imageLoadTaskKey: Swift.String {
    get
  }
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
public protocol ImageWebCacheResourceable {
  var cacheKey: Swift.String { get }
  var downloadUrl: Foundation.URL { get }
}
extension Foundation.URL : RufoofReader.ImageWebCacheResourceable {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadUrl: Foundation.URL {
    get
  }
}
public protocol CipherModeWorker {
  var cipherOperation: RufoofReader.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : RufoofReader.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : RufoofReader.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : RufoofReader.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : RufoofReader.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : RufoofReader.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : RufoofReader.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public class SaveBookManager {
  public init(bookId: Swift.Int, bodyPath: Swift.String, header: Swift.String?, token: Swift.String?)
  public func save() -> Swift.Bool
  @objc deinit
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : RufoofReader._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [RufoofReader.Bit]
  public func bits() -> Swift.String
}
public protocol JukeboxDelegate : AnyObject {
  func jukeboxStateDidChange(_ state: RufoofReader.Jukebox)
  func jukeboxPlaybackProgressDidChange(_ jukebox: RufoofReader.Jukebox)
  func jukeboxDidLoadItem(_ jukebox: RufoofReader.Jukebox, item: RufoofReader.JukeboxItem)
  func jukeboxDidUpdateMetadata(_ jukebox: RufoofReader.Jukebox, forItem: RufoofReader.JukeboxItem)
  func jukeboxDidPlayToEnd()
}
extension RufoofReader.Jukebox {
  public func play()
  public func play(atIndex index: Swift.Int)
  public func pause()
  public func stop()
  public func replay()
  public func playNext()
  public func playPrevious()
  public func replayCurrentItem()
  public func seek(toSecond second: Swift.Int, shouldPlay: Swift.Bool = false)
  public func backToBegining(_ shouldPlay: Swift.Bool)
  public func append(item: RufoofReader.JukeboxItem, loadingAssets: Swift.Bool)
  public func remove(item: RufoofReader.JukeboxItem)
  public func removeItems(withURL url: Foundation.URL)
}
@objc open class Jukebox : ObjectiveC.NSObject {
  public enum State : Swift.Int, Swift.CustomStringConvertible {
    case ready
    case playing
    case paused
    case loading
    case failed
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  weak open var delegate: (any RufoofReader.JukeboxDelegate)? {
    get
  }
  open var playIndex: Swift.Int {
    get
  }
  open var queuedItems: [RufoofReader.JukeboxItem]! {
    get
  }
  open var state: RufoofReader.Jukebox.State {
    get
  }
  open var volume: Swift.Float {
    get
    set
  }
  open var bookCover: UIKit.UIImage?
  open var bookTitle: Swift.String
  open var rate: Swift.Float
  open var currentPlayTime: Swift.Int
  open var updateRate: Swift.Float {
    get
    set
  }
  open var currentItem: RufoofReader.JukeboxItem? {
    get
  }
  required public init?(delegate: (any RufoofReader.JukeboxDelegate)? = nil, items: [RufoofReader.JukeboxItem] = [JukeboxItem]())
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RRUtil {
  @objc deinit
}
public class ReaderStyle {
  public var readerColor: Swift.Int
  public var textSize: Swift.Int
  public var isJustified: Swift.Bool
  public var lineSpacing: RufoofReader.LineSpacing
  public var font: Swift.Int
  public init(readerColor color: Swift.Int, readerTextSize size: Swift.Int, isJustified justification: Swift.Bool, lineSpacing space: RufoofReader.LineSpacing, font textFont: Swift.Int)
  @objc deinit
}
public class OperationState : Swift.Codable {
  public var name: Swift.String
  public var progress: Swift.Int
  public var dependencies: [Swift.String]
  public init(name: Swift.String, progress: Swift.Int, dependencies: [Swift.String])
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension RufoofReader.OperationState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: RufoofReader.CipherError, b: RufoofReader.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension RufoofReader.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public class BlockDecryptor : RufoofReader.Cryptor, RufoofReader.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: RufoofReader.Padding
  @usableFromInline
  internal var worker: any RufoofReader.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RufoofReader.Padding, _ worker: any RufoofReader.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
extension RufoofReader.CS.BigInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RufoofReader.CS.BigUInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers open class RRFont {
  @objc deinit
}
public enum PKCS7 {
}
public protocol MemoryCacheable : RufoofReader.CacheStandard {
  mutating func save(value: Self.Value?, for key: Self.Key, cost: Swift.Int)
}
public protocol DiskCacheable : RufoofReader.CacheAsyncStandard, RufoofReader.CacheStandard {
  init?(path: Swift.String, sizeThreshold threshold: Swift.Int32)
}
public protocol Cacheable {
  associatedtype M : RufoofReader.CacheStandard
  associatedtype D : RufoofReader.CacheAsyncStandard, RufoofReader.CacheStandard where Self.D.Key == Self.M.Key, Self.D.Value == Self.M.Value
  init(memoryCache: Self.M, diskCache: Self.D)
}
public protocol CacheStandard {
  associatedtype Value
  associatedtype Key : Swift.Hashable
  func containsObject(key: Self.Key) -> Swift.Bool
  mutating func query(key: Self.Key) -> Self.Value?
  mutating func save(value: Self.Value?, for key: Self.Key)
  mutating func save(_ dataWork: @escaping () -> (Self.Value, Swift.Int)?, forKey key: Self.Key)
  mutating func remove(key: Self.Key)
  mutating func removeAll()
}
public protocol CacheAsyncStandard {
  associatedtype Value
  associatedtype Key : Swift.Hashable
  func containsObject(key: Self.Key, _ result: @escaping ((_ key: Self.Key, _ contain: Swift.Bool) -> Swift.Void))
  mutating func query(key: Self.Key, _ result: @escaping ((_ key: Self.Key, _ value: Self.Value?) -> Swift.Void))
  mutating func save(value: Self.Value?, for key: Self.Key, _ result: @escaping (() -> Swift.Void))
  mutating func save(_ dataWork: @escaping () -> (Self.Value, Swift.Int)?, forKey key: Self.Key, result: @escaping (() -> Swift.Void))
  mutating func remove(key: Self.Key, _ result: @escaping ((_ key: Self.Key) -> Swift.Void))
  mutating func removeAll(_ result: @escaping (() -> Swift.Void))
}
public enum CacheAge {
  case never
  case seconds(Swift.Int32)
  case minutes(Swift.Int32)
  case hours(Swift.Int32)
  case days(Swift.Int32)
  case expired
}
public struct ImageCacheType : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let none: RufoofReader.ImageCacheType
  public static let memory: RufoofReader.ImageCacheType
  public static let disk: RufoofReader.ImageCacheType
  public static let all: RufoofReader.ImageCacheType
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = RufoofReader.ImageCacheType
  public typealias Element = RufoofReader.ImageCacheType
  public typealias RawValue = Swift.Int
}
public enum ImageCacheQueryCompletionResult {
  case none
  case memory(image: UIKit.UIImage)
  case disk(data: Foundation.Data)
  case all(image: UIKit.UIImage, data: Foundation.Data)
}
public protocol ImageCacheable : AnyObject {
  func image(forKey key: Swift.String, cacheType: RufoofReader.ImageCacheType, completion: @escaping (RufoofReader.ImageCacheQueryCompletionResult) -> Swift.Void)
  func isCached(forKey key: Swift.String) -> (Swift.Bool, RufoofReader.ImageCacheType)
  func diskDataExists(forKey key: Swift.String, completion: ((Swift.Bool) -> Swift.Void)?)
  func store(_ image: UIKit.UIImage?, data: Foundation.Data?, forKey key: Swift.String, cacheType: RufoofReader.ImageCacheType, completion: (() -> Swift.Void)?)
  func removeImage(forKey key: Swift.String, cacheType: RufoofReader.ImageCacheType, completion: ((_ key: Swift.String) -> Swift.Void)?)
  func remove(_ type: RufoofReader.ImageCacheType, completion: (() -> Swift.Void)?)
}
extension RufoofReader.CS.BigUInt {
  public func power(_ exponent: Swift.Int) -> RufoofReader.CS.BigUInt
  public func power(_ exponent: RufoofReader.CS.BigUInt, modulus: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
}
extension RufoofReader.CS.BigInt {
  public func power(_ exponent: Swift.Int) -> RufoofReader.CS.BigInt
  public func power(_ exponent: RufoofReader.CS.BigInt, modulus: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: RufoofReader.HKDF.Error, b: RufoofReader.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: RufoofReader.HMAC.Variant = .sha2(.sha256)) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
  public func callAsFunction() throws -> Swift.Array<Swift.UInt8>
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RufoofReader.Bit {
  @inlinable internal func inverted() -> RufoofReader.Bit {
    self == .zero ? .one : .zero
  }
}
extension RufoofReader.RSA : RufoofReader.Signature {
  final public func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func sign(_ bytes: Swift.Array<Swift.UInt8>, variant: RufoofReader.RSA.SignatureVariant) throws -> Swift.Array<Swift.UInt8>
  final public func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  final public func verify(signature: Swift.Array<Swift.UInt8>, for bytes: Swift.Array<Swift.UInt8>, variant: RufoofReader.RSA.SignatureVariant) throws -> Swift.Bool
}
extension RufoofReader.RSA {
  public enum SignatureVariant {
    case raw
    case message_pkcs1v15_MD5
    case message_pkcs1v15_SHA1
    case message_pkcs1v15_SHA224
    case message_pkcs1v15_SHA256
    case message_pkcs1v15_SHA384
    case message_pkcs1v15_SHA512
    case message_pkcs1v15_SHA512_224
    case message_pkcs1v15_SHA512_256
    case digest_pkcs1v15_RAW
    case digest_pkcs1v15_MD5
    case digest_pkcs1v15_SHA1
    case digest_pkcs1v15_SHA224
    case digest_pkcs1v15_SHA256
    case digest_pkcs1v15_SHA384
    case digest_pkcs1v15_SHA512
    case digest_pkcs1v15_SHA512_224
    case digest_pkcs1v15_SHA512_256
    public static func == (a: RufoofReader.RSA.SignatureVariant, b: RufoofReader.RSA.SignatureVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension RufoofReader.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension RufoofReader.CS.BigInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension Swift.BinaryFloatingPoint where Self.RawExponent : Swift.FixedWidthInteger, Self.RawSignificand : Swift.FixedWidthInteger {
  public init(_ value: RufoofReader.CS.BigInt)
  public init(_ value: RufoofReader.CS.BigUInt)
}
extension Foundation.Data {
  @available(*, deprecated, message: "Please use `Int64` for `size` and provider `position`.")
  public static func compress(size: Swift.Int, bufferSize: Swift.Int, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> RufoofReader.CRC32
  @available(*, deprecated, message: "Please use `Int64` for `size` and provider `position`.")
  public static func decompress(size: Swift.Int, bufferSize: Swift.Int, skipCRC32: Swift.Bool, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> RufoofReader.CRC32
}
extension RufoofReader.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: RufoofReader.Padding = .pkcs7) throws
}
public class BookStorage {
  public init()
  public func getBookInfo(bookId: Swift.Int) -> RufoofReader.RRBookInfo
  public func getLocalBooks() -> [Swift.Int]
  public func isBookLocal(bookId: Swift.Int) -> Swift.Bool
  public func deleteBook(bookId: Swift.Int)
  public func checkDeviceFreeSpace() -> [Swift.Int]
  public func checkDeviceFreeSpace()
  @objc deinit
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
  @inlinable internal subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get {
    return indices.contains(index) ? self[index] : nil
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: RufoofReader.SHA2.Variant) -> [Element]
  public func sha3(_ variant: RufoofReader.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: any RufoofReader.Cipher) throws -> [Element]
  public func decrypt(cipher: any RufoofReader.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : RufoofReader.Authenticator
}
extension RufoofReader.CS {
  public struct BigUInt : Swift.UnsignedInteger {
    public typealias Word = Swift.UInt
    public init()
    public init(words: [RufoofReader.CS.BigUInt.Word])
    public typealias Magnitude = RufoofReader.CS.BigUInt
  }
}
extension RufoofReader.CS.BigUInt {
  public static var isSigned: Swift.Bool {
    get
  }
  public func signum() -> RufoofReader.CS.BigUInt
}
public protocol LayoutAttributesAnimator {
  func animate(collectionView: UIKit.UICollectionView, attributes: RufoofReader.AnimatedCollectionViewLayoutAttributes)
}
extension Dispatch.DispatchQueue : RufoofReader.LonginusCompatible {
}
extension RufoofReader.LonginusExtension where Base : Dispatch.DispatchQueue {
  public func safeAsync(_ work: @escaping () -> Swift.Void)
  public func safeSync(_ work: @escaping () -> Swift.Void)
}
extension Dispatch.DispatchQueue {
  public class func once(file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, block: () -> Swift.Void)
  public class func once(token: Swift.String, block: () -> Swift.Void)
}
@objc open class ConcurrentOperation : Foundation.Operation {
  public var executionBlock: ((_ operation: RufoofReader.ConcurrentOperation) -> Swift.Void)?
  @objc override dynamic open var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var isExecuting: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var isFinished: Swift.Bool {
    @objc get
  }
  open var progress: Swift.Int {
    get
    set
  }
  @available(*, deprecated, renamed: "success")
  open var hasFailed: Swift.Bool {
    get
  }
  open var success: Swift.Bool
  open var maximumRetries: Swift.Int
  open var currentAttempt: Swift.Int {
    get
  }
  open var manualRetry: Swift.Bool
  public init(name: Swift.String? = nil, executionBlock: ((_ operation: RufoofReader.ConcurrentOperation) -> Swift.Void)? = nil)
  @objc override dynamic open func start()
  open func retry()
  open func execute()
  @available(*, deprecated, renamed: "finish(success:)")
  open func finish(_ hasFailed: Swift.Bool)
  open func finish(success: Swift.Bool = true)
  open func pause()
  open func resume()
  @objc deinit
}
extension RufoofReader.ConcurrentOperation {
  public func addToSharedQueuer()
  public func addToQueue(_ queue: RufoofReader.Queuer)
}
public protocol ImageCodeable : AnyObject {
  func canDecode(_ data: Foundation.Data) -> Swift.Bool
  func decodedImage(with data: Foundation.Data) -> UIKit.UIImage?
  func decompressedImage(with image: UIKit.UIImage, data: Foundation.Data) -> UIKit.UIImage?
  func canEncode(_ format: RufoofReader.ImageFormat) -> Swift.Bool
  func encodedData(with image: UIKit.UIImage, format: RufoofReader.ImageFormat) -> Foundation.Data?
  func copy() -> any RufoofReader.ImageCodeable
}
public protocol ImageProgressiveCodeable : RufoofReader.ImageCodeable {
  func canIncrementallyDecode(_ data: Foundation.Data) -> Swift.Bool
  func incrementallyDecodedImage(with data: Foundation.Data, finished: Swift.Bool) -> UIKit.UIImage?
}
public protocol AnimatedImageCodeable {
  var imageData: Foundation.Data? { get set }
  var frameCount: Swift.Int? { get }
  var loopCount: Swift.Int? { get }
  var bytesPerFrame: Swift.Int64? { get }
  func imageFrame(at index: Swift.Int, decompress: Swift.Bool) -> UIKit.UIImage?
  func imageFrameSize(at index: Swift.Int) -> CoreFoundation.CGSize?
  func duration(at index: Swift.Int) -> Foundation.TimeInterval?
  func contentsRect(at index: Swift.Int) -> CoreFoundation.CGRect?
}
extension RufoofReader.AnimatedImageCodeable {
  public func contentsRect(at index: Swift.Int) -> CoreFoundation.CGRect?
}
public enum ImageFormat {
  case unknown
  case JPEG
  case PNG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: RufoofReader.ImageFormat, b: RufoofReader.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RufoofReader.LonginusExtension where Base : RufoofReader.AnimatedImage {
  public var transformer: RufoofReader.ImageTransformer? {
    get
    set
  }
  public var originalImageData: Foundation.Data? {
    get
  }
  public var currentCacheSize: Swift.Int64 {
    get
  }
  public func updateCacheSizeIfNeeded()
  public func preloadImageFrame(fromIndex startIndex: Swift.Int)
  public func preloadAllImageFrames()
  public func didAddToView(_ view: RufoofReader.AnimatedImageView)
  public func didRemoveFromView(_ view: RufoofReader.AnimatedImageView)
  public func cancelPreloadTask()
  public func clearAsynchronously(completion: (() -> Swift.Void)?)
  public func clear()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class AnimatedImage : UIKit.UIImage, RufoofReader.AnimatedImageCodeable {
  @_Concurrency.MainActor(unsafe) public var imageData: Foundation.Data? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var frameCount: Swift.Int?
  @_Concurrency.MainActor(unsafe) public var loopCount: Swift.Int?
  @_Concurrency.MainActor(unsafe) public var bytesPerFrame: Swift.Int64? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func imageFrame(at index: Swift.Int, decompress: Swift.Bool) -> UIKit.UIImage?
  @_Concurrency.MainActor(unsafe) public func imageFrameSize(at index: Swift.Int) -> CoreFoundation.CGSize?
  @_Concurrency.MainActor(unsafe) public func duration(at index: Swift.Int) -> Foundation.TimeInterval?
  @objc deinit
  @_Concurrency.MainActor(unsafe) convenience public init?(lg_data data: Foundation.Data, decoder aDecoder: (any RufoofReader.AnimatedImageCodeable & RufoofReader.ImageCodeable))
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init?(contentsOfFile path: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init?(data: Foundation.Data)
  @available(iOS 6.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init?(data: Foundation.Data, scale: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(cgImage: CoreGraphics.CGImage)
  @available(iOS 4.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(cgImage: CoreGraphics.CGImage, scale: CoreFoundation.CGFloat, orientation: UIKit.UIImage.Orientation)
  @available(iOS 5.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(ciImage: CoreImage.CIImage)
  @available(iOS 6.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(ciImage: CoreImage.CIImage, scale: CoreFoundation.CGFloat, orientation: UIKit.UIImage.Orientation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension RufoofReader.CS {
  public struct BigInt : Swift.SignedInteger {
    public enum Sign {
      case plus
      case minus
      public static func == (a: RufoofReader.CS.BigInt.Sign, b: RufoofReader.CS.BigInt.Sign) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public typealias Magnitude = RufoofReader.CS.BigUInt
    public typealias Word = RufoofReader.CS.BigUInt.Word
    public static var isSigned: Swift.Bool {
      get
    }
    public var magnitude: RufoofReader.CS.BigUInt
    public var sign: RufoofReader.CS.BigInt.Sign
    public init(sign: RufoofReader.CS.BigInt.Sign, magnitude: RufoofReader.CS.BigUInt)
    public var isZero: Swift.Bool {
      get
    }
    public func signum() -> RufoofReader.CS.BigInt
  }
}
public protocol ReaderDelegate {
  func onStyleChanged(style: RufoofReader.ReaderStyle)
  func onPositionChanged(position: Swift.Int)
  func onBookDetailsCLicked()
  func onSaveBookClicked(position: Swift.Int)
  func onShareBook()
  func onDownloadBook()
  func onSyncNotesAndMarks(list: [RufoofReader.NotesAndMarks])
  func onReaderClosed(position: Swift.Int)
  func onSampleEnded()
}
extension RufoofReader.CS.BigUInt {
  public mutating func multiply(byWord y: RufoofReader.CS.BigUInt.Word)
  public func multiplied(byWord y: RufoofReader.CS.BigUInt.Word) -> RufoofReader.CS.BigUInt
  public mutating func multiplyAndAdd(_ x: RufoofReader.CS.BigUInt, _ y: RufoofReader.CS.BigUInt.Word, shiftedBy shift: Swift.Int = 0)
  public func multiplied(by y: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public static var directMultiplicationLimit: Swift.Int
  public static func * (x: RufoofReader.CS.BigUInt, y: RufoofReader.CS.BigUInt) -> RufoofReader.CS.BigUInt
  public static func *= (a: inout RufoofReader.CS.BigUInt, b: RufoofReader.CS.BigUInt)
}
extension RufoofReader.CS.BigInt {
  public static func * (a: RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt) -> RufoofReader.CS.BigInt
  public static func *= (a: inout RufoofReader.CS.BigInt, b: RufoofReader.CS.BigInt)
}
public struct QueryImageCacheResult {
  public var image: UIKit.UIImage? {
    get
  }
  public var imageFormat: RufoofReader.ImageFormat? {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  public var error: (any Swift.Error)? {
    get
  }
  public var cacheType: RufoofReader.ImageCacheType {
    get
  }
}
public class LonginusManager {
  public static let shared: RufoofReader.LonginusManager
  public var imageCacher: RufoofReader.ImageCacher? {
    get
  }
  public var imageDownloader: any RufoofReader.ImageDownloadable {
    get
  }
  public var imageCoder: any RufoofReader.ImageCodeable {
    get
  }
  public var preloadTasks: [Swift.String : RufoofReader.ImageLoadTask] {
    get
  }
  public var defaultOptions: RufoofReader.LonginusImageOptions
  public var currentTaskCount: Swift.Int {
    get
  }
  public var currentPreloadTaskCount: Swift.Int {
    get
  }
  convenience public init(cachePath: Swift.String, sizeThreshold: Swift.Int32)
  public init(cacher: RufoofReader.ImageCacher?, downloader: any RufoofReader.ImageDownloadable, coder: any RufoofReader.ImageCodeable)
  @discardableResult
  public func loadImage(with resource: any RufoofReader.ImageWebCacheResourceable, options: RufoofReader.LonginusImageOptions? = nil, transformer: RufoofReader.ImageTransformer? = nil, progress: RufoofReader.ImageDownloaderProgressBlock? = nil, completion: @escaping RufoofReader.ImageManagerCompletionBlock) -> RufoofReader.ImageLoadTask
  @discardableResult
  public func preload(_ resources: [any RufoofReader.ImageWebCacheResourceable], options: RufoofReader.LonginusImageOptions? = nil, progress: RufoofReader.ImagePreloadProgress? = nil, completion: RufoofReader.ImagePreloadCompletion? = nil) -> [RufoofReader.ImageLoadTask]
  public func cancelPreloading(url: Swift.String)
  public func cancelPreloading()
  public func cancelAll()
  public func queryImageFromCacheWithType(byKey key: Swift.String, cacheType: RufoofReader.ImageCacheType = .all) -> RufoofReader.QueryImageCacheResult
  public func queryImageFromCacheWithType(byKey key: Swift.String, cacheType: RufoofReader.ImageCacheType, completion: @escaping (RufoofReader.QueryImageCacheResult) -> Swift.Void)
  @objc deinit
}
public protocol StatsSessionDelegate {
  func onReadingSessionEnd(session: RufoofReader.RRReadingSession)
}
public class ImageIOCoder : RufoofReader.ImageCodeable {
  public func canDecode(_ data: Foundation.Data) -> Swift.Bool
  public func decodedImage(with data: Foundation.Data) -> UIKit.UIImage?
  public func decompressedImage(with image: UIKit.UIImage, data: Foundation.Data) -> UIKit.UIImage?
  public func canEncode(_ format: RufoofReader.ImageFormat) -> Swift.Bool
  public func encodedData(with image: UIKit.UIImage, format: RufoofReader.ImageFormat) -> Foundation.Data?
  public func copy() -> any RufoofReader.ImageCodeable
  public init()
  @objc deinit
}
extension RufoofReader.ImageIOCoder {
  public static func decompressedImage(_ sourceImage: CoreGraphics.CGImage) -> CoreGraphics.CGImage?
}
extension RufoofReader.ImageIOCoder : RufoofReader.ImageProgressiveCodeable {
  public func canIncrementallyDecode(_ data: Foundation.Data) -> Swift.Bool
  public func incrementallyDecodedImage(with data: Foundation.Data, finished: Swift.Bool) -> UIKit.UIImage?
}
extension RufoofReader.CS.BigUInt {
  public func squareRoot() -> RufoofReader.CS.BigUInt
}
extension RufoofReader.CS.BigInt {
  public func squareRoot() -> RufoofReader.CS.BigInt
}
extension Swift.String {
  public func decryptBase64ToString(cipher: any RufoofReader.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: any RufoofReader.Cipher) throws -> Swift.Array<Swift.UInt8>
}
public enum AnimationsType : Swift.Int {
  case ANIMATION_NONE
  case ANIMATION_CARD_PAGE
  case ANIMATION_ROTATION
  case ANIMATION_ZOOM
  case ANIMATION_CUBE_OUT
  case ANIMATION_PARALLAX
  case ANIMATION_CROSS_FADE
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ScrollOrientation : Swift.Int {
  case ORIENTATION_HORIZONTAL
  case ORIENTATION_VERTICAL
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum LineSpacing : Swift.Int {
  case LINESPACE_SMALL
  case LINESPACE_MEDIUM
  case LINESPACE_LARGE
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ReaderColors : Swift.Int {
  case LIGHT
  case BROWN
  case DARK
  case GREEN
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ActionsType : Swift.String {
  case noAction
  case subscribeAction
  case saveAction
  case saveDownloadAction
  case unSaveAction
  case downloadAction
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FontWeight : Swift.String {
  case WEIGHT_BOLD
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MarkStyle : Swift.Int {
  case MARK_BOLD
  case MARK_ITALIC
  case MARK_BIG
  case MARK_SMALL
  case MARK_BLOCKQUOTE
  case MARK_MONOSPACE
  case MARK_UNDERLINE
  case MARK_SUPER
  case MARK_SUB
  case MARK_POETRY_RIGHT
  case MARK_POETRY_LEFT
  case MARK_CENTER
  case MARK_COLOR
  case MARK_A
  case MARK_HEADER
  case MARK_PAGE
  case MARK_IMAGE
  case POETRY_MARGIN
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum FontType : Swift.String {
  case FONT_DEFAULT
  case FONT_GRITA
  case FONT_IBM_PLEX_SANS
  case FONT_MIRZA
  case FONT_ALMARAI
  case FONT_LEMONADA
  case FONT_EL_MESSIRI
  case FONT_TAJAWAL
  case FONT_AREF_RUQAA
  case FONT_MADA
  case FONT_HARMATTAN
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FontNamesAr : Swift.String {
  case FONT_DEFAULT
  case FONT_GRITA
  case FONT_IBM_PLEX_SANS
  case FONT_MIRZA
  case FONT_ALMARAI
  case FONT_LEMONADA
  case FONT_EL_MESSIRI
  case FONT_TAJAWAL
  case FONT_AREF_RUQAA
  case FONT_MADA
  case FONT_HARMATTAN
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FontNamesEn : Swift.String {
  case FONT_DEFAULT
  case FONT_GRITA
  case FONT_IBM_PLEX_SANS
  case FONT_MIRZA
  case FONT_ALMARAI
  case FONT_LEMONADA
  case FONT_EL_MESSIRI
  case FONT_TAJAWAL
  case FONT_AREF_RUQAA
  case FONT_MADA
  case FONT_HARMATTAN
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum BookType : Swift.String {
  case BOOK_EPUB
  case BOOK_SYNC
  case BOOK_AUDIO
  case BOOK_PDF
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum BookLanguage : Swift.String {
  case LANGUAGE_AR
  case LANGUAGE_EN
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SaveState : Swift.String {
  case SAVED
  case NOT_SAVED
  case DISBALED
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RRPanModalHeight : Swift.Equatable {
  case maxHeight
  case maxHeightWithTopInset(CoreFoundation.CGFloat)
  case contentHeight(CoreFoundation.CGFloat)
  case contentHeightIgnoringSafeArea(CoreFoundation.CGFloat)
  case intrinsicHeight
  public static func == (a: RufoofReader.RRPanModalHeight, b: RufoofReader.RRPanModalHeight) -> Swift.Bool
}
public class CMAC : RufoofReader.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: RufoofReader.CMAC.Error, b: RufoofReader.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: any RufoofReader.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public protocol MarkSliderDelegate {
  func didSelectMark(chapterIndex: Swift.Int, pageIndex: Swift.Int, pageNo: Swift.Int, markPage: Swift.Int)
  func didSetValue()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class MarkSlider : UIKit.UISlider {
  public enum MarkStyle {
    case shape(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat)
    case image(image: UIKit.UIImage)
  }
  @_Concurrency.MainActor(unsafe) open var pagesIndex: [Swift.Int]
  @_Concurrency.MainActor(unsafe) open var chaptersIndex: [Swift.Int]
  @_Concurrency.MainActor(unsafe) open var pagesNo: [Swift.Int]
  @_Concurrency.MainActor(unsafe) open var markPagesNo: [Swift.Int] {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var value: Swift.Float {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var isStayToMark: Swift.Bool
  @_Concurrency.MainActor(unsafe) open var markStyle: RufoofReader.MarkSlider.MarkStyle
  @_Concurrency.MainActor(unsafe) open var minimumMarkTintColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) open var maximumMarkTintColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
  @objc deinit
}
extension RufoofReader.MarkSlider {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
}
extension Swift.String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: RufoofReader.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: any RufoofReader.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: any RufoofReader.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : RufoofReader.Authenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
extension RufoofReader.Archive {
  final public func totalUnitCountForRemoving(_ entry: RufoofReader.Entry) -> Swift.Int64
  final public func totalUnitCountForReading(_ entry: RufoofReader.Entry) -> Swift.Int64
  final public func totalUnitCountForAddingItem(at url: Foundation.URL) -> Swift.Int64
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension RufoofReader.MD5 : RufoofReader.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@objc @_inheritsConvenienceInitializers public class RRPanModalPresentationDelegate : ObjectiveC.NSObject {
  public static var `default`: RufoofReader.RRPanModalPresentationDelegate
  @objc override dynamic public init()
  @objc deinit
}
extension RufoofReader.RRPanModalPresentationDelegate : UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func animationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController, source: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func animationController(forDismissed dismissed: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func presentationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController?, source: UIKit.UIViewController) -> UIKit.UIPresentationController?
}
extension RufoofReader.RRPanModalPresentationDelegate : UIKit.UIAdaptivePresentationControllerDelegate, UIKit.UIPopoverPresentationControllerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func adaptivePresentationStyle(for controller: UIKit.UIPresentationController, traitCollection: UIKit.UITraitCollection) -> UIKit.UIModalPresentationStyle
}
public typealias ImageTransformMethod = (UIKit.UIImage) -> UIKit.UIImage?
public var lg_shareCIContext: CoreImage.CIContext {
  get
}
public func lg_clearCIContext()
public struct ImageTransformer {
  public var key: Swift.String
  public var transform: RufoofReader.ImageTransformMethod
  public init(key: Swift.String, transform: @escaping RufoofReader.ImageTransformMethod)
}
extension RufoofReader.ImageTransformer {
  public static func imageTransformerCrop(with rect: CoreFoundation.CGRect) -> RufoofReader.ImageTransformer
  public static func imageTransformerResize(with size: CoreFoundation.CGSize) -> RufoofReader.ImageTransformer
  public static func imageTransformerResize(with displaySize: CoreFoundation.CGSize, contentMode: UIKit.UIView.ContentMode) -> RufoofReader.ImageTransformer
  public static func imageTransformerResize(with displaySize: CoreFoundation.CGSize, fillContentMode: RufoofReader.LonginusExtension<UIKit.UIView>.FillContentMode) -> RufoofReader.ImageTransformer
  public static func imageTransformerRotate(withAngle angle: CoreFoundation.CGFloat, fitSize: Swift.Bool) -> RufoofReader.ImageTransformer
  public static func imageTransformerFlip(withHorizontal horizontal: Swift.Bool, vertical: Swift.Bool) -> RufoofReader.ImageTransformer
  public static func imageTransformerTint(with color: UIKit.UIColor, blendMode: CoreGraphics.CGBlendMode = .destinationIn) -> RufoofReader.ImageTransformer
  public static func imageTransformerGradientlyTint(with colors: [UIKit.UIColor], locations: [CoreFoundation.CGFloat], start: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0), end: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 1), blendMode: CoreGraphics.CGBlendMode = .normal) -> RufoofReader.ImageTransformer
  public static func imageTransformerOverlay(with overlayImage: UIKit.UIImage, blendMode: CoreGraphics.CGBlendMode = .normal, alpha: CoreFoundation.CGFloat) -> RufoofReader.ImageTransformer
  public static func imageTransformerCornerRadius(radius: CoreFoundation.CGFloat, corners: UIKit.UIRectCorner, borderWidth: CoreFoundation.CGFloat, borderColor: UIKit.UIColor) -> RufoofReader.ImageTransformer
  public static func imageTransformerCommon(with displaySize: CoreFoundation.CGSize, fillContentMode: RufoofReader.LonginusExtension<UIKit.UIView>.FillContentMode = .center, maxResolution: Swift.Int = 0, corner: UIKit.UIRectCorner = UIRectCorner(rawValue: 0), cornerRadius: CoreFoundation.CGFloat = 0, borderWidth: CoreFoundation.CGFloat = 0, borderColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil) -> RufoofReader.ImageTransformer
}
extension RufoofReader.LonginusExtension where Base : UIKit.UIImage {
  public var imageByBlurExtraLight: UIKit.UIImage? {
    get
  }
  public var imageByBlurLight: UIKit.UIImage? {
    get
  }
  public var imageByBlurDark: UIKit.UIImage? {
    get
  }
  public func image(byBlurRadius blurRadius: CoreFoundation.CGFloat, tintColor: UIKit.UIColor?, tintMode tintBlendMode: CoreGraphics.CGBlendMode, saturation: CoreFoundation.CGFloat, maskImage: UIKit.UIImage?) -> UIKit.UIImage?
  public func croppedImage(with originalRect: CoreFoundation.CGRect) -> UIKit.UIImage?
  public func resizedImage(with size: CoreFoundation.CGSize) -> UIKit.UIImage?
  public func resizedImage(with displaySize: CoreFoundation.CGSize, contentMode: UIKit.UIView.ContentMode) -> UIKit.UIImage?
  public func resizedImage(with displaySize: CoreFoundation.CGSize, fillContentMode: RufoofReader.LonginusExtension<UIKit.UIView>.FillContentMode) -> UIKit.UIImage?
  public func rotatedImage(withAngle angle: CoreFoundation.CGFloat, fitSize: Swift.Bool) -> UIKit.UIImage?
  public func flippedImage(withHorizontal horizontal: Swift.Bool, vertical: Swift.Bool) -> UIKit.UIImage?
  public func tintedImage(with color: UIKit.UIColor, blendMode: CoreGraphics.CGBlendMode = .destinationIn) -> UIKit.UIImage?
  public func gradientlyTintedImage(with colors: [UIKit.UIColor], locations: [CoreFoundation.CGFloat], start: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0), end: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 1), blendMode: CoreGraphics.CGBlendMode = .normal) -> UIKit.UIImage?
  public func overlaidImage(with overlayImage: UIKit.UIImage, blendMode: CoreGraphics.CGBlendMode = .normal, alpha: CoreFoundation.CGFloat) -> UIKit.UIImage?
  public func roundCornerRadius(radius: CoreFoundation.CGFloat, corners: UIKit.UIRectCorner, borderWidth: CoreFoundation.CGFloat, borderColor: UIKit.UIColor, backgroundColor: UIKit.UIColor? = .clear) -> UIKit.UIImage?
  public func commonEditedImage(with displaySize: CoreFoundation.CGSize, fillContentMode: RufoofReader.LonginusExtension<UIKit.UIView>.FillContentMode = .center, maxResolution: Swift.Int = 0, corner: UIKit.UIRectCorner = UIRectCorner(rawValue: 0), cornerRadius: CoreFoundation.CGFloat = 0, borderWidth: CoreFoundation.CGFloat = 0, borderColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = .clear) -> UIKit.UIImage?
}
extension RufoofReader.CS.BigUInt {
  public subscript(bitAt index: Swift.Int) -> Swift.Bool {
    get
    set
  }
}
extension RufoofReader.CS.BigUInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension RufoofReader.CS.BigInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension RufoofReader.CS.BigUInt {
  public struct Words : Swift.RandomAccessCollection {
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> RufoofReader.CS.BigUInt.Word {
      get
    }
    public typealias Element = RufoofReader.CS.BigUInt.Word
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Iterator = Swift.IndexingIterator<RufoofReader.CS.BigUInt.Words>
    public typealias SubSequence = Swift.Slice<RufoofReader.CS.BigUInt.Words>
  }
  public var words: RufoofReader.CS.BigUInt.Words {
    get
  }
  public init<Words>(words: Words) where Words : Swift.Sequence, Words.Element == Swift.UInt
}
extension RufoofReader.CS.BigInt {
  public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.CountableRange<Swift.Int>
    public var count: Swift.Int {
      get
    }
    public var indices: RufoofReader.CS.BigInt.Words.Indices {
      get
    }
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      get
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<RufoofReader.CS.BigInt.Words>
    public typealias SubSequence = Swift.Slice<RufoofReader.CS.BigInt.Words>
  }
  public var words: RufoofReader.CS.BigInt.Words {
    get
  }
  public init<S>(words: S) where S : Swift.Sequence, S.Element == Swift.UInt
}
extension RufoofReader.Entry.EntryType : Swift.Equatable {}
extension RufoofReader.Entry.EntryType : Swift.Hashable {}
extension RufoofReader.Entry.EntryType : Swift.RawRepresentable {}
extension RufoofReader.PCBC.Error : Swift.Equatable {}
extension RufoofReader.PCBC.Error : Swift.Hashable {}
extension RufoofReader.Padding : Swift.Equatable {}
extension RufoofReader.Padding : Swift.Hashable {}
extension RufoofReader.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension RufoofReader.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension RufoofReader.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension RufoofReader.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension RufoofReader.Language : Swift.Equatable {}
extension RufoofReader.Language : Swift.Hashable {}
extension RufoofReader.Language : Swift.RawRepresentable {}
extension RufoofReader.Blowfish.Error : Swift.Equatable {}
extension RufoofReader.Blowfish.Error : Swift.Hashable {}
extension RufoofReader.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension RufoofReader.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension RufoofReader.KVStorageType : Swift.Equatable {}
extension RufoofReader.KVStorageType : Swift.Hashable {}
@available(iOS 10.0, *)
extension RufoofReader.UnfairLock.Predicate : Swift.Equatable {}
@available(iOS 10.0, *)
extension RufoofReader.UnfairLock.Predicate : Swift.Hashable {}
extension RufoofReader.SignatureError : Swift.Equatable {}
extension RufoofReader.SignatureError : Swift.Hashable {}
extension RufoofReader.RSA.RSAEncryptionVariant : Swift.Equatable {}
extension RufoofReader.RSA.RSAEncryptionVariant : Swift.Hashable {}
extension RufoofReader.RSA.RSAEncryptionVariant : Swift.Sendable {}
extension RufoofReader.CTR : RufoofReader.BlockMode {}
extension RufoofReader.CTR.Error : Swift.Equatable {}
extension RufoofReader.CTR.Error : Swift.Hashable {}
extension RufoofReader.Rabbit.Error : Swift.Equatable {}
extension RufoofReader.Rabbit.Error : Swift.Hashable {}
extension RufoofReader.GCM.Mode : Swift.Equatable {}
extension RufoofReader.GCM.Mode : Swift.Hashable {}
extension RufoofReader.GCM.Error : Swift.Equatable {}
extension RufoofReader.GCM.Error : Swift.Hashable {}
extension RufoofReader.RRSwiftData.DataType : Swift.Equatable {}
extension RufoofReader.RRSwiftData.DataType : Swift.Hashable {}
extension RufoofReader.RRSwiftData.Flags : Swift.Equatable {}
extension RufoofReader.RRSwiftData.Flags : Swift.Hashable {}
extension RufoofReader.AES.Error : Swift.Equatable {}
extension RufoofReader.AES.Error : Swift.Hashable {}
extension RufoofReader.AES.Variant : Swift.Equatable {}
extension RufoofReader.AES.Variant : Swift.Hashable {}
extension RufoofReader.AES.Variant : Swift.RawRepresentable {}
extension RufoofReader.OCB.Mode : Swift.Equatable {}
extension RufoofReader.OCB.Mode : Swift.Hashable {}
extension RufoofReader.OCB.Error : Swift.Equatable {}
extension RufoofReader.OCB.Error : Swift.Hashable {}
extension RufoofReader.RRPanModalPresentationController.PresentationState : Swift.Equatable {}
extension RufoofReader.RRPanModalPresentationController.PresentationState : Swift.Hashable {}
extension RufoofReader.RSA.Error : Swift.Equatable {}
extension RufoofReader.RSA.Error : Swift.Hashable {}
extension RufoofReader.CFB.Error : Swift.Equatable {}
extension RufoofReader.CFB.Error : Swift.Hashable {}
extension RufoofReader.CFB.SegmentSize : Swift.Equatable {}
extension RufoofReader.CFB.SegmentSize : Swift.Hashable {}
extension RufoofReader.CFB.SegmentSize : Swift.RawRepresentable {}
extension RufoofReader.ChaCha20.Error : Swift.Equatable {}
extension RufoofReader.ChaCha20.Error : Swift.Hashable {}
extension RufoofReader.XChaCha20.Error : Swift.Equatable {}
extension RufoofReader.XChaCha20.Error : Swift.Hashable {}
extension RufoofReader.CompressionMethod : Swift.Equatable {}
extension RufoofReader.CompressionMethod : Swift.Hashable {}
extension RufoofReader.CompressionMethod : Swift.RawRepresentable {}
extension RufoofReader.HMAC.Error : Swift.Equatable {}
extension RufoofReader.HMAC.Error : Swift.Hashable {}
extension RufoofReader.SHA3.Variant : Swift.Equatable {}
extension RufoofReader.SHA3.Variant : Swift.Hashable {}
extension RufoofReader.OFB.Error : Swift.Equatable {}
extension RufoofReader.OFB.Error : Swift.Hashable {}
extension RufoofReader.RRPanModalPresentationAnimator.TransitionStyle : Swift.Equatable {}
extension RufoofReader.RRPanModalPresentationAnimator.TransitionStyle : Swift.Hashable {}
extension RufoofReader.Poly1305.Error : Swift.Equatable {}
extension RufoofReader.Poly1305.Error : Swift.Hashable {}
extension RufoofReader.AnimatedImageViewType : Swift.Equatable {}
extension RufoofReader.AnimatedImageViewType : Swift.Hashable {}
extension RufoofReader.CBC.Error : Swift.Equatable {}
extension RufoofReader.CBC.Error : Swift.Hashable {}
extension RufoofReader.CCM : RufoofReader.BlockMode {}
extension RufoofReader.CCM.Error : Swift.Equatable {}
extension RufoofReader.CCM.Error : Swift.Hashable {}
extension RufoofReader.Archive.ArchiveError : Swift.Equatable {}
extension RufoofReader.Archive.ArchiveError : Swift.Hashable {}
extension RufoofReader.Archive.AccessMode : Swift.Equatable {}
extension RufoofReader.Archive.AccessMode : Swift.Hashable {}
extension RufoofReader.Archive.AccessMode : Swift.RawRepresentable {}
extension RufoofReader.SHA2.Variant : Swift.Equatable {}
extension RufoofReader.SHA2.Variant : Swift.Hashable {}
extension RufoofReader.SHA2.Variant : Swift.Sendable {}
extension RufoofReader.Jukebox.State : Swift.Equatable {}
extension RufoofReader.Jukebox.State : Swift.Hashable {}
extension RufoofReader.Jukebox.State : Swift.RawRepresentable {}
extension RufoofReader.CipherError : Swift.Equatable {}
extension RufoofReader.CipherError : Swift.Hashable {}
extension RufoofReader.HKDF.Error : Swift.Equatable {}
extension RufoofReader.HKDF.Error : Swift.Hashable {}
extension RufoofReader.Bit : Swift.Equatable {}
extension RufoofReader.Bit : Swift.Hashable {}
extension RufoofReader.Bit : Swift.RawRepresentable {}
extension RufoofReader.RSA.SignatureVariant : Swift.Equatable {}
extension RufoofReader.RSA.SignatureVariant : Swift.Hashable {}
extension RufoofReader.ImageFormat : Swift.Equatable {}
extension RufoofReader.ImageFormat : Swift.Hashable {}
extension RufoofReader.CS.BigInt.Sign : Swift.Equatable {}
extension RufoofReader.CS.BigInt.Sign : Swift.Hashable {}
extension RufoofReader.AnimationsType : Swift.Equatable {}
extension RufoofReader.AnimationsType : Swift.Hashable {}
extension RufoofReader.AnimationsType : Swift.RawRepresentable {}
extension RufoofReader.ScrollOrientation : Swift.Equatable {}
extension RufoofReader.ScrollOrientation : Swift.Hashable {}
extension RufoofReader.ScrollOrientation : Swift.RawRepresentable {}
extension RufoofReader.LineSpacing : Swift.Equatable {}
extension RufoofReader.LineSpacing : Swift.Hashable {}
extension RufoofReader.LineSpacing : Swift.RawRepresentable {}
extension RufoofReader.ReaderColors : Swift.Equatable {}
extension RufoofReader.ReaderColors : Swift.Hashable {}
extension RufoofReader.ReaderColors : Swift.RawRepresentable {}
extension RufoofReader.ActionsType : Swift.Equatable {}
extension RufoofReader.ActionsType : Swift.Hashable {}
extension RufoofReader.ActionsType : Swift.RawRepresentable {}
extension RufoofReader.FontWeight : Swift.Equatable {}
extension RufoofReader.FontWeight : Swift.Hashable {}
extension RufoofReader.FontWeight : Swift.RawRepresentable {}
extension RufoofReader.MarkStyle : Swift.Equatable {}
extension RufoofReader.MarkStyle : Swift.Hashable {}
extension RufoofReader.MarkStyle : Swift.RawRepresentable {}
extension RufoofReader.FontType : Swift.Equatable {}
extension RufoofReader.FontType : Swift.Hashable {}
extension RufoofReader.FontType : Swift.RawRepresentable {}
extension RufoofReader.FontNamesAr : Swift.Equatable {}
extension RufoofReader.FontNamesAr : Swift.Hashable {}
extension RufoofReader.FontNamesAr : Swift.RawRepresentable {}
extension RufoofReader.FontNamesEn : Swift.Equatable {}
extension RufoofReader.FontNamesEn : Swift.Hashable {}
extension RufoofReader.FontNamesEn : Swift.RawRepresentable {}
extension RufoofReader.BookType : Swift.Equatable {}
extension RufoofReader.BookType : Swift.Hashable {}
extension RufoofReader.BookType : Swift.RawRepresentable {}
extension RufoofReader.BookLanguage : Swift.Equatable {}
extension RufoofReader.BookLanguage : Swift.Hashable {}
extension RufoofReader.BookLanguage : Swift.RawRepresentable {}
extension RufoofReader.SaveState : Swift.Equatable {}
extension RufoofReader.SaveState : Swift.Hashable {}
extension RufoofReader.SaveState : Swift.RawRepresentable {}
extension RufoofReader.CMAC.Error : Swift.Equatable {}
extension RufoofReader.CMAC.Error : Swift.Hashable {}
